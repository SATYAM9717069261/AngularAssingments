{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, Output, ViewChild, ComponentFactoryResolver, ApplicationRef, forwardRef, ViewEncapsulation, Injectable, Optional, Pipe, HostBinding, HostListener, NgModule, InjectionToken } from '@angular/core';\nimport * as i4 from '@angular/forms';\nimport { NG_VALUE_ACCESSOR, FormGroup, FormControl, Validators as Validators$1, ReactiveFormsModule } from '@angular/forms';\nimport { Plugin, PluginKey, NodeSelection, EditorState } from 'prosemirror-state';\nimport { DecorationSet, Decoration, EditorView } from 'prosemirror-view';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { Fragment, Slice, DOMSerializer, DOMParser } from 'prosemirror-model';\nimport { schema } from 'ngx-editor/schema';\nexport { marks, nodes, schema } from 'ngx-editor/schema';\nimport { Subject, fromEvent, asyncScheduler } from 'rxjs';\nimport { toggleMark, lift, wrapIn, setBlockType, newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock, chainCommands, exitCode, baseKeymap } from 'prosemirror-commands';\nimport { applyMark, removeLink, removeMark } from 'ngx-editor/commands';\nimport { isMarkActive, isNodeActive, getSelectionNodes, getSelectionMarks } from 'ngx-editor/helpers';\nimport { liftListItem, wrapInList, splitListItem, sinkListItem } from 'prosemirror-schema-list';\nimport * as i1 from '@angular/platform-browser';\nimport { throttleTime } from 'rxjs/operators';\nimport { isNil } from 'ngx-editor/utils';\nimport { keymap } from 'prosemirror-keymap';\nimport { undo, redo, history } from 'prosemirror-history';\nimport { wrappingInputRule, textblockTypeInputRule, smartQuotes, ellipsis, emDash, inputRules } from 'prosemirror-inputrules';\nconst _c0 = [\"imgEl\"];\n\nfunction ImageViewComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵelementStart(1, \"span\", 5);\n    i0.ɵɵlistener(\"mousedown\", function ImageViewComponent_span_1_Template_span_mousedown_1_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.startResizing($event, \"left\");\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\", 6);\n    i0.ɵɵlistener(\"mousedown\", function ImageViewComponent_span_1_Template_span_mousedown_2_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.startResizing($event, \"right\");\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"span\", 7);\n    i0.ɵɵlistener(\"mousedown\", function ImageViewComponent_span_1_Template_span_mousedown_3_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.startResizing($event, \"left\");\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\", 8);\n    i0.ɵɵlistener(\"mousedown\", function ImageViewComponent_span_1_Template_span_mousedown_4_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.startResizing($event, \"right\");\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c1 = function (a0) {\n  return {\n    \"NgxEditor__Resizer--Active\": a0\n  };\n};\n\nconst _c2 = [\"ngxEditor\"];\nconst _c3 = [\"*\"];\n\nfunction LinkComponent_div_2_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", (ctx_r1.href.errors == null ? null : ctx_r1.href.errors.pattern) && \"Please enter valid url.\", \" \");\n  }\n}\n\nfunction LinkComponent_div_2_div_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", (ctx_r2.text.errors == null ? null : ctx_r2.text.errors.required) && \"This is required\", \" \");\n  }\n}\n\nfunction LinkComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵelementStart(1, \"form\", 3);\n    i0.ɵɵlistener(\"ngSubmit\", function LinkComponent_div_2_Template_form_ngSubmit_1_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.insertLink($event);\n    });\n    i0.ɵɵelementStart(2, \"div\", 4);\n    i0.ɵɵelementStart(3, \"div\", 5);\n    i0.ɵɵelementStart(4, \"label\", 6);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(6, \"input\", 7);\n    i0.ɵɵtemplate(7, LinkComponent_div_2_div_7_Template, 2, 1, \"div\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(8, \"div\", 4);\n    i0.ɵɵelementStart(9, \"div\", 5);\n    i0.ɵɵelementStart(10, \"label\", 6);\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(12, \"input\", 9);\n    i0.ɵɵtemplate(13, LinkComponent_div_2_div_13_Template, 2, 1, \"div\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(14, \"div\", 4);\n    i0.ɵɵelementStart(15, \"div\", 5);\n    i0.ɵɵelementStart(16, \"label\");\n    i0.ɵɵelement(17, \"input\", 10);\n    i0.ɵɵtext(18);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(19, \"button\", 11);\n    i0.ɵɵtext(20);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"formGroup\", ctx_r0.form);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r0.getLabel(\"url\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.href.touched && ctx_r0.href.invalid);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r0.getLabel(\"text\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.text.touched && ctx_r0.text.invalid);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.getLabel(\"openInNewTab\"), \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", !ctx_r0.form.valid);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.getLabel(\"insert\"));\n  }\n}\n\nfunction ImageComponent_div_2_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", (ctx_r1.src.errors == null ? null : ctx_r1.src.errors.pattern) && \"Please enter valid url.\", \" \");\n  }\n}\n\nfunction ImageComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵelementStart(1, \"form\", 3);\n    i0.ɵɵlistener(\"ngSubmit\", function ImageComponent_div_2_Template_form_ngSubmit_1_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.insertLink($event);\n    });\n    i0.ɵɵelementStart(2, \"div\", 4);\n    i0.ɵɵelementStart(3, \"div\", 5);\n    i0.ɵɵelementStart(4, \"label\", 6);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(6, \"input\", 7);\n    i0.ɵɵtemplate(7, ImageComponent_div_2_div_7_Template, 2, 1, \"div\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(8, \"div\", 4);\n    i0.ɵɵelementStart(9, \"div\", 5);\n    i0.ɵɵelementStart(10, \"label\", 6);\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(12, \"input\", 9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(13, \"div\", 4);\n    i0.ɵɵelementStart(14, \"div\", 5);\n    i0.ɵɵelementStart(15, \"label\", 6);\n    i0.ɵɵtext(16);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(17, \"input\", 10);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(18, \"button\", 11);\n    i0.ɵɵtext(19);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"formGroup\", ctx_r0.form);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r0.getLabel(\"url\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.src.touched && ctx_r0.src.invalid);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r0.getLabel(\"altText\"));\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate(ctx_r0.getLabel(\"title\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"disabled\", !ctx_r0.form.valid || !ctx_r0.form.dirty);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.getLabel(\"insert\"));\n  }\n}\n\nconst _c4 = function (a0, a1) {\n  return {\n    \"NgxEditor__Dropdown--Active\": a0,\n    \"NgxEditor--Disabled\": a1\n  };\n};\n\nfunction DropdownComponent_div_2_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵlistener(\"mousedown\", function DropdownComponent_div_2_div_1_Template_div_mousedown_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r4);\n      const item_r2 = restoredCtx.$implicit;\n      const ctx_r3 = i0.ɵɵnextContext(2);\n      return ctx_r3.onClick($event, item_r2);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r2 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(2, _c4, item_r2 === ctx_r1.activeItem, ctx_r1.disabledItems.includes(item_r2)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.getName(item_r2), \" \");\n  }\n}\n\nfunction DropdownComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵtemplate(1, DropdownComponent_div_2_div_1_Template, 2, 5, \"div\", 3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.items);\n  }\n}\n\nconst _c5 = function (a0, a1) {\n  return {\n    backgroundColor: a0,\n    color: a1\n  };\n};\n\nconst _c6 = function (a0) {\n  return {\n    \"NgxEditor__Color--Active\": a0\n  };\n};\n\nfunction ColorPickerComponent_div_2_div_1_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 7);\n    i0.ɵɵlistener(\"mousedown\", function ColorPickerComponent_div_2_div_1_button_1_Template_button_mousedown_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r6);\n      const color_r4 = restoredCtx.$implicit;\n      const ctx_r5 = i0.ɵɵnextContext(3);\n      return ctx_r5.onColorSelect($event, color_r4);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const color_r4 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction2(3, _c5, color_r4, ctx_r3.getContrastYIQ(color_r4)))(\"title\", color_r4)(\"ngClass\", i0.ɵɵpureFunction1(6, _c6, ctx_r3.activeColors.includes(color_r4)));\n  }\n}\n\nfunction ColorPickerComponent_div_2_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵtemplate(1, ColorPickerComponent_div_2_div_1_button_1_Template, 1, 8, \"button\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const colorGroup_r2 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", colorGroup_r2);\n  }\n}\n\nfunction ColorPickerComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵtemplate(1, ColorPickerComponent_div_2_div_1_Template, 2, 1, \"div\", 3);\n    i0.ɵɵelementStart(2, \"button\", 4);\n    i0.ɵɵlistener(\"mousedown\", function ColorPickerComponent_div_2_Template_button_mousedown_2_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.remove($event);\n    });\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.presets);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", !ctx_r0.isActive);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.getLabel(\"remove\"), \" \");\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_ngx_toggle_command_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ngx-toggle-command\", 7);\n  }\n\n  if (rf & 2) {\n    const item_r5 = i0.ɵɵnextContext().$implicit;\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMap(ctx_r7.iconContainerClass);\n    i0.ɵɵproperty(\"toolbarItem\", item_r5);\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_ngx_link_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ngx-link\");\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(3);\n    i0.ɵɵclassMap(ctx_r8.iconContainerClass);\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_ngx_image_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ngx-image\");\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(3);\n    i0.ɵɵclassMap(ctx_r9.iconContainerClass);\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_ng_container_4_ngx_dropdown_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ngx-dropdown\", 9);\n  }\n\n  if (rf & 2) {\n    const dropdownItem_r16 = ctx.$implicit;\n    const ctx_r15 = i0.ɵɵnextContext(4);\n    i0.ɵɵclassMap(ctx_r15.dropdownContainerClass);\n    i0.ɵɵproperty(\"group\", dropdownItem_r16.key)(\"items\", dropdownItem_r16.value);\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, MenuComponent_ng_container_1_ng_container_1_ng_container_4_ngx_dropdown_1_Template, 1, 4, \"ngx-dropdown\", 8);\n    i0.ɵɵpipe(2, \"keyvalue\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r5 = i0.ɵɵnextContext().$implicit;\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(2, 1, ctx_r10.getDropdownItems(item_r5)));\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_ngx_color_picker_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ngx-color-picker\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(3);\n    i0.ɵɵclassMap(ctx_r11.iconContainerClass);\n    i0.ɵɵproperty(\"presets\", ctx_r11.presets);\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_ngx_color_picker_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ngx-color-picker\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(3);\n    i0.ɵɵclassMap(ctx_r12.iconContainerClass);\n    i0.ɵɵproperty(\"presets\", ctx_r12.presets);\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\");\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(3);\n    i0.ɵɵclassMap(ctx_r13.seperatorClass);\n  }\n}\n\nfunction MenuComponent_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, MenuComponent_ng_container_1_ng_container_1_ngx_toggle_command_1_Template, 1, 3, \"ngx-toggle-command\", 3);\n    i0.ɵɵtemplate(2, MenuComponent_ng_container_1_ng_container_1_ngx_link_2_Template, 1, 2, \"ngx-link\", 4);\n    i0.ɵɵtemplate(3, MenuComponent_ng_container_1_ng_container_1_ngx_image_3_Template, 1, 2, \"ngx-image\", 4);\n    i0.ɵɵtemplate(4, MenuComponent_ng_container_1_ng_container_1_ng_container_4_Template, 3, 3, \"ng-container\", 2);\n    i0.ɵɵtemplate(5, MenuComponent_ng_container_1_ng_container_1_ngx_color_picker_5_Template, 1, 3, \"ngx-color-picker\", 5);\n    i0.ɵɵtemplate(6, MenuComponent_ng_container_1_ng_container_1_ngx_color_picker_6_Template, 1, 3, \"ngx-color-picker\", 6);\n    i0.ɵɵtemplate(7, MenuComponent_ng_container_1_ng_container_1_div_7_Template, 1, 2, \"div\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r5 = ctx.$implicit;\n    const lastItem_r6 = ctx.last;\n    const lastToolbarItem_r3 = i0.ɵɵnextContext().last;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.toggleCommands.includes(item_r5));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r5 === \"link\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r5 === \"image\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.isDropDown(item_r5));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r5 === \"text_color\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r5 === \"background_color\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", lastItem_r6 && !lastToolbarItem_r3);\n  }\n}\n\nfunction MenuComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, MenuComponent_ng_container_1_ng_container_1_Template, 8, 7, \"ng-container\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const toolbarItem_r2 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", toolbarItem_r2);\n  }\n}\n\nfunction MenuComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementContainer(1, 12);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.customMenuRef);\n  }\n}\n\nconst _c7 = function (a0, a1) {\n  return {\n    \"NgxEditor--Disabled\": a0,\n    \"NgxEditor__MenuBar--Reverse\": a1\n  };\n};\n\nconst _c8 = function (a0, a1) {\n  return {\n    \"NgxBubbleMenu__Icon--Active\": a0,\n    \"NgxEditor--Disabled\": a1\n  };\n};\n\nfunction BubbleComponent_ng_container_0_ng_container_1_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵlistener(\"mousedown\", function BubbleComponent_ng_container_0_ng_container_1_div_1_Template_div_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const item_r4 = i0.ɵɵnextContext().$implicit;\n      const ctx_r8 = i0.ɵɵnextContext(2);\n      return ctx_r8.onClick($event, item_r4);\n    });\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(1, \"svg\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r4 = i0.ɵɵnextContext().$implicit;\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(3, _c8, ctx_r6.activeItems.includes(item_r4), !ctx_r6.execulableItems.includes(item_r4)))(\"title\", ctx_r6.getTitle(item_r4));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"innerHTML\", ctx_r6.getIcon(item_r4), i0.ɵɵsanitizeHtml);\n  }\n}\n\nfunction BubbleComponent_ng_container_0_ng_container_1_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 5);\n  }\n}\n\nfunction BubbleComponent_ng_container_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, BubbleComponent_ng_container_0_ng_container_1_div_1_Template, 2, 6, \"div\", 1);\n    i0.ɵɵtemplate(2, BubbleComponent_ng_container_0_ng_container_1_div_2_Template, 1, 0, \"div\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r4 = ctx.$implicit;\n    const lastItem_r5 = ctx.last;\n    const lastToolbarItem_r2 = i0.ɵɵnextContext().last;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.toggleCommands.includes(item_r4));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", lastItem_r5 && !lastToolbarItem_r2);\n  }\n}\n\nfunction BubbleComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, BubbleComponent_ng_container_0_ng_container_1_Template, 3, 2, \"ng-container\", 0);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const toolbarItem_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", toolbarItem_r1);\n  }\n}\n\nfunction FloatingMenuComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"ngx-bubble\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"editor\", ctx_r1.editor);\n  }\n}\n\nconst editablePlugin = (editable = true) => {\n  return new Plugin({\n    key: new PluginKey('editable'),\n    state: {\n      init() {\n        return editable;\n      },\n\n      apply(tr, previousVal) {\n        var _a;\n\n        return (_a = tr.getMeta('UPDATE_EDITABLE')) !== null && _a !== void 0 ? _a : previousVal;\n      }\n\n    },\n    props: {\n      editable(state) {\n        return this.getState(state);\n      },\n\n      attributes(state) {\n        const isEnabled = this.getState(state);\n\n        if (isEnabled) {\n          return null;\n        }\n\n        return {\n          class: 'NgxEditor__Content--Disabled'\n        };\n      }\n\n    }\n  });\n};\n\nconst PLACEHOLDER_CLASSNAME = 'NgxEditor__Placeholder';\n\nconst placeholderPlugin = text => {\n  return new Plugin({\n    key: new PluginKey('placeholder'),\n    state: {\n      init() {\n        return text !== null && text !== void 0 ? text : '';\n      },\n\n      apply(tr, previousVal) {\n        var _a;\n\n        const placeholder = (_a = tr.getMeta('UPDATE_PLACEHOLDER')) !== null && _a !== void 0 ? _a : previousVal;\n        return placeholder;\n      }\n\n    },\n    props: {\n      decorations(state) {\n        const {\n          doc\n        } = state;\n        const {\n          textContent,\n          childCount\n        } = doc;\n        const placeholder = this.getState(state);\n\n        if (!placeholder || childCount > 1) {\n          return DecorationSet.empty;\n        }\n\n        const decorations = [];\n\n        const decorate = (node, pos) => {\n          var _a;\n\n          if (node.type.isBlock && node.childCount === 0 && textContent.length === 0) {\n            const placeholderNode = Decoration.node(pos, pos + node.nodeSize, {\n              class: PLACEHOLDER_CLASSNAME,\n              'data-placeholder': placeholder,\n              'data-align': (_a = node.attrs.align) !== null && _a !== void 0 ? _a : null\n            });\n            decorations.push(placeholderNode);\n          }\n\n          return false;\n        };\n\n        doc.descendants(decorate);\n        return DecorationSet.create(doc, decorations);\n      }\n\n    }\n  });\n};\n\nconst attributesPlugin = (attributes = {}) => {\n  return new Plugin({\n    key: new PluginKey('attributes'),\n    props: {\n      attributes\n    }\n  });\n};\n\nconst focusPlugin = cb => {\n  return new Plugin({\n    key: new PluginKey('focus'),\n    props: {\n      handleDOMEvents: {\n        focus: () => {\n          cb();\n          return false;\n        }\n      }\n    }\n  });\n};\n\nconst blurPlugin = cb => {\n  return new Plugin({\n    key: new PluginKey('blur'),\n    props: {\n      handleDOMEvents: {\n        blur: () => {\n          cb();\n          return false;\n        }\n      }\n    }\n  });\n};\n\nlet ImageViewComponent = /*@__PURE__*/(() => {\n  class ImageViewComponent {\n    constructor() {\n      this.alt = '';\n      this.title = '';\n      this.outerWidth = '';\n      this.selected = false;\n      this.imageResize = new EventEmitter();\n    }\n\n    startResizing(e, direction) {\n      e.preventDefault();\n      this.resizeImage(e, direction);\n    }\n\n    resizeImage(evt, direction) {\n      const startX = evt.pageX;\n      const startWidth = this.imgEl.nativeElement.clientWidth;\n      const isLeftResize = direction === 'left';\n      const {\n        width\n      } = window.getComputedStyle(this.view.dom);\n      const editorWidth = parseInt(width, 10);\n\n      const onMouseMove = e => {\n        const currentX = e.pageX;\n        const diffInPx = currentX - startX;\n        const computedWidth = isLeftResize ? startWidth - diffInPx : startWidth + diffInPx; // prevent image overflow the editor\n        // prevent resizng below 20px\n\n        if (computedWidth > editorWidth || computedWidth < 20) {\n          return;\n        }\n\n        this.outerWidth = `${computedWidth}px`;\n      };\n\n      const onMouseUp = e => {\n        e.preventDefault();\n        document.removeEventListener('mousemove', onMouseMove);\n        document.removeEventListener('mouseup', onMouseUp);\n        this.imageResize.emit();\n      };\n\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', onMouseUp);\n    }\n\n  }\n\n  ImageViewComponent.ɵfac = function ImageViewComponent_Factory(t) {\n    return new (t || ImageViewComponent)();\n  };\n\n  ImageViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ImageViewComponent,\n    selectors: [[\"ngx-image-view\"]],\n    viewQuery: function ImageViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.imgEl = _t.first);\n      }\n    },\n    inputs: {\n      src: \"src\",\n      alt: \"alt\",\n      title: \"title\",\n      outerWidth: \"outerWidth\",\n      selected: \"selected\",\n      view: \"view\"\n    },\n    outputs: {\n      imageResize: \"imageResize\"\n    },\n    decls: 4,\n    vars: 9,\n    consts: [[1, \"NgxEditor__ImageWrapper\", 3, \"ngClass\"], [\"class\", \"NgxEditor__ResizeHandle\", 4, \"ngIf\"], [3, \"src\", \"alt\", \"title\"], [\"imgEl\", \"\"], [1, \"NgxEditor__ResizeHandle\"], [1, \"NgxEditor__ResizeHandle--TL\", 3, \"mousedown\"], [1, \"NgxEditor__ResizeHandle--TR\", 3, \"mousedown\"], [1, \"NgxEditor__ResizeHandle--BL\", 3, \"mousedown\"], [1, \"NgxEditor__ResizeHandle--BR\", 3, \"mousedown\"]],\n    template: function ImageViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵtemplate(1, ImageViewComponent_span_1_Template, 5, 0, \"span\", 1);\n        i0.ɵɵelement(2, \"img\", 2, 3);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.outerWidth);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(7, _c1, ctx.selected));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.selected);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"src\", ctx.src, i0.ɵɵsanitizeUrl)(\"alt\", ctx.alt)(\"title\", ctx.title);\n      }\n    },\n    directives: [i3.NgClass, i3.NgIf],\n    styles: [\"*[_ngcontent-%COMP%], [_ngcontent-%COMP%]:after, [_ngcontent-%COMP%]:before{box-sizing:border-box}img[_ngcontent-%COMP%]{width:100%;height:100%}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]{position:relative;display:inline-block;line-height:0;padding:2px}.NgxEditor__ImageWrapper.NgxEditor__Resizer--Active[_ngcontent-%COMP%]{padding:1px;border:1px solid #1a73e8}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]{position:absolute;height:100%;width:100%}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--BL[_ngcontent-%COMP%], .NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--BR[_ngcontent-%COMP%], .NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--TL[_ngcontent-%COMP%], .NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--TR[_ngcontent-%COMP%]{position:absolute;width:7px;height:7px;background-color:#1a73e8;border:1px solid #fff}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--BR[_ngcontent-%COMP%]{bottom:-5px;right:-5px;cursor:se-resize}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--TR[_ngcontent-%COMP%]{top:-5px;right:-5px;cursor:ne-resize}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--TL[_ngcontent-%COMP%]{top:-5px;left:-5px;cursor:nw-resize}.NgxEditor__ImageWrapper[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle[_ngcontent-%COMP%]   .NgxEditor__ResizeHandle--BL[_ngcontent-%COMP%]{bottom:-5px;left:-5px;cursor:sw-resize}\"]\n  });\n  return ImageViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImageViewComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-image-view',\n      templateUrl: './image-view.component.html',\n      styleUrls: ['./image-view.component.scss']\n    }]\n  }], null, {\n    src: [{\n      type: Input\n    }],\n    alt: [{\n      type: Input\n    }],\n    title: [{\n      type: Input\n    }],\n    outerWidth: [{\n      type: Input\n    }],\n    selected: [{\n      type: Input\n    }],\n    view: [{\n      type: Input\n    }],\n    imageResize: [{\n      type: Output\n    }],\n    imgEl: [{\n      type: ViewChild,\n      args: ['imgEl', {\n        static: true\n      }]\n    }]\n  });\n})();\n\nclass ImageRezieView {\n  constructor(node, view, getPos, injector) {\n    this.updating = false;\n\n    this.handleResize = () => {\n      if (this.updating) {\n        return;\n      }\n\n      const {\n        state,\n        dispatch\n      } = this.view;\n      const {\n        tr\n      } = state;\n      const transaction = tr.setNodeMarkup(this.getPos(), undefined, {\n        src: this.imageComponentRef.instance.src,\n        width: this.imageComponentRef.instance.outerWidth\n      });\n      const resolvedPos = transaction.doc.resolve(this.getPos());\n      const newSelection = new NodeSelection(resolvedPos);\n      transaction.setSelection(newSelection);\n      dispatch(transaction);\n    };\n\n    const dom = document.createElement('image-view');\n    const componentFactoryResolver = injector.get(ComponentFactoryResolver);\n    this.applicationRef = injector.get(ApplicationRef); // Create the component and wire it up with the element\n\n    const factory = componentFactoryResolver.resolveComponentFactory(ImageViewComponent);\n    this.imageComponentRef = factory.create(injector, [], dom); // Attach to the view so that the change detector knows to run\n\n    this.applicationRef.attachView(this.imageComponentRef.hostView);\n    this.setNodeAttributes(node.attrs);\n    this.imageComponentRef.instance.view = view;\n    this.dom = dom;\n    this.view = view;\n    this.node = node;\n    this.getPos = getPos;\n    this.resizeSubscription = this.imageComponentRef.instance.imageResize.subscribe(() => {\n      this.handleResize();\n    });\n  }\n\n  computeChanges(prevAttrs, newAttrs) {\n    return JSON.stringify(prevAttrs) === JSON.stringify(newAttrs);\n  }\n\n  setNodeAttributes(attrs) {\n    this.imageComponentRef.instance.src = attrs.src;\n    this.imageComponentRef.instance.alt = attrs.alt;\n    this.imageComponentRef.instance.title = attrs.title;\n    this.imageComponentRef.instance.outerWidth = attrs.width;\n  }\n\n  update(node) {\n    if (node.type !== this.node.type) {\n      return false;\n    }\n\n    this.node = node;\n    const changed = this.computeChanges(this.node.attrs, node.attrs);\n\n    if (changed) {\n      this.updating = true;\n      this.setNodeAttributes(node.attrs);\n      this.updating = false;\n    }\n\n    return true;\n  }\n\n  ignoreMutation() {\n    return true;\n  }\n\n  selectNode() {\n    this.imageComponentRef.instance.selected = true;\n  }\n\n  deselectNode() {\n    this.imageComponentRef.instance.selected = false;\n  }\n\n  destroy() {\n    this.resizeSubscription.unsubscribe();\n    this.applicationRef.detachView(this.imageComponentRef.hostView);\n  }\n\n}\n\nconst imagePlugin = injector => {\n  return new Plugin({\n    key: new PluginKey('link'),\n    props: {\n      nodeViews: {\n        image: (node, view, getPos) => {\n          return new ImageRezieView(node, view, getPos, injector);\n        }\n      }\n    }\n  });\n};\n\nconst HTTP_LINK_REGEX = /((https?:\\/\\/)?[\\w-]+(\\.[\\w-]+)+\\.?(:\\d+)?(\\/\\S*)?)$/;\n\nconst linkify = fragment => {\n  const linkified = [];\n  fragment.forEach(child => {\n    if (child.isText) {\n      const text = child.text;\n      let pos = 0;\n      const match = HTTP_LINK_REGEX.exec(text);\n\n      if (match) {\n        const start = match.index;\n        const end = start + match[0].length;\n        const link = child.type.schema.marks.link;\n\n        if (start > 0) {\n          linkified.push(child.cut(pos, start));\n        }\n\n        const urlText = text.slice(start, end);\n        linkified.push(child.cut(start, end).mark(link.create({\n          href: urlText\n        }).addToSet(child.marks)));\n        pos = end;\n      }\n\n      if (pos < text.length) {\n        linkified.push(child.cut(pos));\n      }\n    } else {\n      linkified.push(child.copy(linkify(child.content)));\n    }\n  });\n  return Fragment.fromArray(linkified);\n};\n\nconst linkPlugin = () => {\n  return new Plugin({\n    key: new PluginKey('link'),\n    props: {\n      transformPasted: slice => {\n        return new Slice(linkify(slice.content), slice.openStart, slice.openEnd);\n      }\n    }\n  });\n};\n\nconst emptyDoc = {\n  type: 'doc',\n  content: [{\n    type: 'paragraph'\n  }]\n}; // https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment\n\nconst toHTML = (json, inputSchema) => {\n  const schema$1 = inputSchema !== null && inputSchema !== void 0 ? inputSchema : schema;\n  const contentNode = schema$1.nodeFromJSON(json);\n  const html = DOMSerializer.fromSchema(schema$1).serializeFragment(contentNode.content);\n  const div = document.createElement('div');\n  div.appendChild(html);\n  return div.innerHTML;\n};\n\nconst toDoc = (html, inputSchema) => {\n  const schema$1 = inputSchema !== null && inputSchema !== void 0 ? inputSchema : schema;\n  const el = document.createElement('div');\n  el.innerHTML = html;\n  return DOMParser.fromSchema(schema$1).parse(el).toJSON();\n};\n\nconst parseContent = (value, schema) => {\n  if (!value) {\n    return schema.nodeFromJSON(emptyDoc);\n  }\n\n  if (typeof value !== 'string') {\n    return schema.nodeFromJSON(value);\n  }\n\n  const docJson = toDoc(value, schema);\n  return schema.nodeFromJSON(docJson);\n};\n\nlet NgxEditorComponent = /*@__PURE__*/(() => {\n  class NgxEditorComponent {\n    constructor(_renderer, _injector, _elementRef) {\n      this._renderer = _renderer;\n      this._injector = _injector;\n      this._elementRef = _elementRef;\n      this.placeholder = 'Type Here...';\n      this.focusOut = new EventEmitter();\n      this.focusIn = new EventEmitter();\n      this.subscriptions = [];\n\n      this.onChange = () => {};\n\n      this.onTouched = () => {};\n    }\n\n    writeValue(value) {\n      if (!this.outputFormat && typeof value === 'string') {\n        this.outputFormat = 'html';\n      }\n\n      this.editor.setContent(value);\n    }\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    setDisabledState(isDisabled) {\n      this.setMeta('UPDATE_EDITABLE', !isDisabled);\n\n      this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n    }\n\n    handleChange(jsonDoc) {\n      if (this.outputFormat === 'html') {\n        const html = toHTML(jsonDoc, this.editor.schema);\n        this.onChange(html);\n        return;\n      }\n\n      this.onChange(jsonDoc);\n    }\n\n    setMeta(key, value) {\n      const {\n        dispatch,\n        state: {\n          tr\n        }\n      } = this.editor.view;\n      dispatch(tr.setMeta(key, value));\n    }\n\n    setPlaceholder(placeholder) {\n      this.setMeta('UPDATE_PLACEHOLDER', placeholder);\n    }\n\n    registerPlugins() {\n      this.editor.registerPlugin(editablePlugin());\n      this.editor.registerPlugin(placeholderPlugin(this.placeholder));\n      this.editor.registerPlugin(attributesPlugin({\n        class: 'NgxEditor__Content'\n      }));\n      this.editor.registerPlugin(focusPlugin(() => {\n        this.focusIn.emit();\n      }));\n      this.editor.registerPlugin(focusPlugin(() => {\n        this.focusIn.emit();\n      }));\n      this.editor.registerPlugin(blurPlugin(() => {\n        this.focusOut.emit();\n        this.onTouched();\n      }));\n      this.editor.registerPlugin(imagePlugin(this._injector));\n      this.editor.registerPlugin(linkPlugin());\n    }\n\n    ngOnInit() {\n      if (!this.editor) {\n        throw new Error('NgxEditor: Required editor instance');\n      }\n\n      this.registerPlugins();\n\n      this._renderer.appendChild(this.ngxEditor.nativeElement, this.editor.view.dom);\n\n      const contentChangeSubscription = this.editor.valueChanges.subscribe(jsonDoc => {\n        this.handleChange(jsonDoc);\n      });\n      this.subscriptions.push(contentChangeSubscription);\n    }\n\n    ngOnChanges(changes) {\n      if ((changes === null || changes === void 0 ? void 0 : changes.placeholder) && !changes.placeholder.isFirstChange()) {\n        this.setPlaceholder(changes.placeholder.currentValue);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(subscription => {\n        subscription.unsubscribe();\n      });\n    }\n\n  }\n\n  NgxEditorComponent.ɵfac = function NgxEditorComponent_Factory(t) {\n    return new (t || NgxEditorComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  NgxEditorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxEditorComponent,\n    selectors: [[\"ngx-editor\"]],\n    viewQuery: function NgxEditorComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c2, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ngxEditor = _t.first);\n      }\n    },\n    inputs: {\n      editor: \"editor\",\n      outputFormat: \"outputFormat\",\n      placeholder: \"placeholder\"\n    },\n    outputs: {\n      focusOut: \"focusOut\",\n      focusIn: \"focusIn\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => NgxEditorComponent),\n      multi: true\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c3,\n    decls: 3,\n    vars: 0,\n    consts: [[1, \"NgxEditor\"], [\"ngxEditor\", \"\"]],\n    template: function NgxEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n      }\n    },\n    styles: [\".NgxEditor{background:#fff;color:#000;background-clip:padding-box;border-radius:4px;border:1px solid rgba(0,0,0,.2);position:relative}.NgxEditor--Disabled{opacity:.5;pointer-events:none}.NgxEditor__Placeholder:before{color:#6c757d;opacity:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;cursor:text;content:attr(data-placeholder)}.NgxEditor__Placeholder[data-align=right]:before{position:relative}.NgxEditor__Content{padding:.5rem;white-space:pre-wrap;outline:none;font-variant-ligatures:none;font-feature-settings:\\\"liga\\\" 0,none}.NgxEditor__Content p{margin:0 0 .7rem}.NgxEditor__Content blockquote{padding-left:1rem;border-left:3px solid #ddd;margin-left:0;margin-right:0}.NgxEditor__Content--Disabled{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none}.NgxEditor__Wrapper{border:1px solid rgba(0,0,0,.4);border-radius:4px}.NgxEditor__Wrapper .NgxEditor__MenuBar{border-top-left-radius:4px;border-top-right-radius:4px;border-bottom:1px solid rgba(0,0,0,.2)}.NgxEditor__Wrapper .NgxEditor{border-top-left-radius:0;border-top-right-radius:0;border:none}.NgxEditor__MenuBar{display:flex;padding:.2rem;cursor:default;background-color:#fff}.NgxEditor__MenuItem{border-radius:2px;display:flex;align-items:center;justify-content:center;position:relative;flex-shrink:0}.NgxEditor__MenuItem:hover{background-color:#f1f1f1}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon{height:1.85rem;width:1.85rem;transition:.3s ease-in-out}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon+.NgxEditor__MenuItem--Icon{margin-left:2px}.NgxEditor__MenuItem .NgxEditor__MenuItem--IconContainer{display:flex;height:100%;width:100%;align-items:center;justify-content:center}.NgxEditor__MenuItem.NgxEditor__MenuItem--Text{padding:0 .3rem}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active{background-color:#e8f0fe}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active.NgxEditor__MenuItem--Text{color:#1a73e8}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active svg{fill:#1a73e8}.NgxEditor__Dropdown{min-width:4rem;position:relative;display:flex;align-items:center;flex-shrink:0}.NgxEditor__Dropdown:hover{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text{display:flex;align-items:center;justify-content:center;padding:0 .3rem;height:100%;width:100%}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text:after{display:inline-block;content:\\\"\\\";margin-left:1.5rem;vertical-align:.25rem;border-top:.25rem solid;border-right:.25rem solid transparent;border-bottom:0;border-left:.25rem solid transparent}.NgxEditor__Dropdown .NgxEditor__Dropdown--DropdownMenu{position:absolute;left:0;box-shadow:0 2px 6px 2px rgba(60,64,67,.15);border-radius:4px;background-color:#fff;z-index:10;width:100%;top:calc(1.85rem + 2px)}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item{padding:.5rem;white-space:nowrap;color:inherit}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item:hover{background-color:#ececec}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected{background-color:#e8f0fe}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open .NgxEditor__Dropdown--Text,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected .NgxEditor__Dropdown--Text{color:#1a73e8}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active:hover{background-color:#e7e7e7}.NgxEditor__MenuBar--Reverse .NgxEditor__Dropdown--DropdownMenu{top:unset;bottom:calc(1.85rem + 2px)}.NgxEditor__MenuBar--Reverse .NgxEditor__Dropdown--Text:after{transform:rotate(180deg)}.NgxEditor__MenuBar--Reverse .NgxEditor__Popup{top:unset;bottom:calc(1.85rem + 2px)}.NgxEditor__Popup{position:absolute;top:calc(1.85rem + 2px);box-shadow:0 2px 6px 2px rgba(60,64,67,.15);border-radius:4px;background-color:#fff;z-index:10;min-width:12rem;padding:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup{margin-bottom:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup label{margin-bottom:3px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=text],.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=url]{padding:2px 4px}.NgxEditor__Popup .NgxEditor__Popup--Col{display:flex;flex-direction:column;position:relative}.NgxEditor__Popup .NgxEditor__Popup--Label{font-size:85%}.NgxEditor__Seperator{border-left:1px solid #ccc;margin:0 .3rem}.NgxEditor__HelpText{font-size:80%}.NgxEditor__HelpText.NgxEditor__HelpText--Error{color:red}\"],\n    encapsulation: 2\n  });\n  return NgxEditorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxEditorComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-editor',\n      templateUrl: './editor.component.html',\n      styleUrls: ['./editor.component.scss'],\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(() => NgxEditorComponent),\n        multi: true\n      }],\n      encapsulation: ViewEncapsulation.None\n    }]\n  }], function () {\n    return [{\n      type: i0.Renderer2\n    }, {\n      type: i0.Injector\n    }, {\n      type: i0.ElementRef\n    }];\n  }, {\n    ngxEditor: [{\n      type: ViewChild,\n      args: ['ngxEditor', {\n        static: true\n      }]\n    }],\n    editor: [{\n      type: Input\n    }],\n    outputFormat: [{\n      type: Input\n    }],\n    placeholder: [{\n      type: Input\n    }],\n    focusOut: [{\n      type: Output\n    }],\n    focusIn: [{\n      type: Output\n    }]\n  });\n})();\n\nlet MenuService = /*@__PURE__*/(() => {\n  class MenuService {\n    constructor() {\n      this.customMenuRefChange = new Subject();\n    }\n\n    setCustomMenuRef(c) {\n      this.customMenuRefChange.next(c);\n    }\n\n  }\n\n  MenuService.ɵfac = function MenuService_Factory(t) {\n    return new (t || MenuService)();\n  };\n\n  MenuService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MenuService,\n    factory: MenuService.ɵfac,\n    providedIn: 'root'\n  });\n  return MenuService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MenuService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\nvar bold = `\n  <path d=\"M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z\" />\n`;\nvar italic = `\n  <path d=\"M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z\" />\n`;\nvar code = `\n<path d=\"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z\"/>\n`;\nvar underline = `\n<path d=\"M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z\"/>\n`;\nvar strike = `\n<path d=\"M6.85,7.08C6.85,4.37,9.45,3,12.24,3c1.64,0,3,0.49,3.9,1.28c0.77,0.65,1.46,1.73,1.46,3.24h-3.01 c0-0.31-0.05-0.59-0.15-0.85c-0.29-0.86-1.2-1.28-2.25-1.28c-1.86,0-2.34,1.02-2.34,1.7c0,0.48,0.25,0.88,0.74,1.21 C10.97,8.55,11.36,8.78,12,9H7.39C7.18,8.66,6.85,8.11,6.85,7.08z M21,12v-2H3v2h9.62c1.15,0.45,1.96,0.75,1.96,1.97 c0,1-0.81,1.67-2.28,1.67c-1.54,0-2.93-0.54-2.93-2.51H6.4c0,0.55,0.08,1.13,0.24,1.58c0.81,2.29,3.29,3.3,5.67,3.3 c2.27,0,5.3-0.89,5.3-4.05c0-0.3-0.01-1.16-0.48-1.94H21V12z\"/>\n`;\nvar orderedList = `\n<path d=\"M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z\"/>\n`;\nvar bulletList = `\n<path d=\"M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z\"/>\n`;\nvar quote = `\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z\"/>\n`;\nvar link = `\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z\"/>\n`;\nvar unlink = `\n<path d=\"M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11C3.29 8.12 2 9.91 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z\"/>\n`;\nvar image = `\n<path d=\"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z\"/>\n`;\nvar alignLeft = `\n<path d=\"M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z\"/>\n`;\nvar alignCenter = `\n<path d=\"M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z\"/>\n`;\nvar alignRight = `\n<path d=\"M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z\"/>\n`;\nvar alignJustify = `\n<path d=\"M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z\"/>\n`;\nvar textColor = `\n<path d=\"M2,20h20v4H2V20z M5.49,17h2.42l1.27-3.58h5.65L16.09,17h2.42L13.25,3h-2.5L5.49,17z M9.91,11.39l2.03-5.79h0.12l2.03,5.79 H9.91z\"/>\n`;\nvar colorFill = `\n<path d=\"M16.56,8.94L7.62,0L6.21,1.41l2.38,2.38L3.44,8.94c-0.59,0.59-0.59,1.54,0,2.12l5.5,5.5C9.23,16.85,9.62,17,10,17 s0.77-0.15,1.06-0.44l5.5-5.5C17.15,10.48,17.15,9.53,16.56,8.94z M5.21,10L10,5.21L14.79,10H5.21z M19,11.5c0,0-2,2.17-2,3.5 c0,1.1,0.9,2,2,2s2-0.9,2-2C21,13.67,19,11.5,19,11.5z M2,20h20v4H2V20z\"/>\n`; // Icons source: https://material.io/\n\nconst DEFAULT_ICON_HEIGHT = 20;\nconst DEFAULT_ICON_WIDTH = 20;\nconst icons = {\n  bold,\n  italic,\n  code,\n  underline,\n  strike,\n  ordered_list: orderedList,\n  bullet_list: bulletList,\n  blockquote: quote,\n  link,\n  unlink,\n  image,\n  align_left: alignLeft,\n  align_center: alignCenter,\n  align_right: alignRight,\n  align_justify: alignJustify,\n  text_color: textColor,\n  color_fill: colorFill\n};\n\nclass Icon {\n  static get(name, fill = '#000') {\n    const path = icons[name] || '<path></path>';\n    return `\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 24 24\"\n        fill=${fill}\n        height=${DEFAULT_ICON_HEIGHT}\n        width=${DEFAULT_ICON_WIDTH}\n      >\n        ${path}\n      </svg>\n    `;\n  }\n\n  static getPath(name) {\n    const path = icons[name] || '<path></path>';\n    return path;\n  }\n\n}\n\nclass Mark {\n  constructor(name) {\n    this.name = name;\n  }\n\n  apply() {\n    return (state, dispatch) => {\n      const {\n        schema\n      } = state;\n      const type = schema.marks[this.name];\n\n      if (!type) {\n        return false;\n      }\n\n      return applyMark(type)(state, dispatch);\n    };\n  }\n\n  toggle() {\n    return (state, dispatch) => {\n      const {\n        schema\n      } = state;\n      const type = schema.marks[this.name];\n\n      if (!type) {\n        return false;\n      }\n\n      return toggleMark(type)(state, dispatch);\n    };\n  }\n\n  isActive(state) {\n    const {\n      schema\n    } = state;\n    const type = schema.marks[this.name];\n\n    if (!type) {\n      return false;\n    }\n\n    return isMarkActive(state, type);\n  }\n\n  canExecute(state) {\n    return this.toggle()(state);\n  }\n\n}\n\nclass Blockqote {\n  toggle() {\n    return (state, dispatch) => {\n      const {\n        schema\n      } = state;\n      const type = schema.nodes.blockquote;\n\n      if (!type) {\n        return false;\n      }\n\n      if (this.isActive(state)) {\n        return lift(state, dispatch);\n      }\n\n      return wrapIn(type)(state, dispatch);\n    };\n  }\n\n  isActive(state) {\n    const {\n      schema\n    } = state;\n    const type = schema.nodes.blockquote;\n\n    if (!type) {\n      return false;\n    }\n\n    return isNodeActive(state, type);\n  }\n\n  canExecute(state) {\n    return this.toggle()(state);\n  }\n\n}\n\nclass ListItem {\n  constructor(isBulletList = false) {\n    this.isBulletList = false;\n    this.isBulletList = isBulletList;\n  }\n\n  getType(schema) {\n    return this.isBulletList ? schema.nodes.bullet_list : schema.nodes.ordered_list;\n  }\n\n  toggle() {\n    return (state, dispatch) => {\n      const {\n        schema\n      } = state;\n      const type = this.getType(schema);\n\n      if (!type) {\n        return false;\n      }\n\n      if (this.isActive(state)) {\n        return liftListItem(schema.nodes.list_item)(state, dispatch);\n      }\n\n      return wrapInList(type)(state, dispatch);\n    };\n  }\n\n  isActive(state) {\n    const {\n      schema\n    } = state;\n    const type = this.getType(schema);\n\n    if (!type) {\n      return false;\n    }\n\n    return isNodeActive(state, type);\n  }\n\n  canExecute(state) {\n    return this.toggle()(state);\n  }\n\n}\n\nclass Heading {\n  constructor(level) {\n    this.level = level;\n  }\n\n  apply() {\n    return (state, dispatch) => {\n      const {\n        schema\n      } = state;\n      const type = schema.nodes.heading;\n\n      if (!type) {\n        return false;\n      }\n\n      return setBlockType(type)(state, dispatch);\n    };\n  }\n\n  toggle() {\n    return (state, dispatch) => {\n      var _a;\n\n      const {\n        schema,\n        selection,\n        doc\n      } = state;\n      const type = schema.nodes.heading;\n\n      if (!type) {\n        return false;\n      }\n\n      const nodePos = selection.$from.before(1);\n      const node = doc.nodeAt(nodePos);\n      const attrs = (_a = node === null || node === void 0 ? void 0 : node.attrs) !== null && _a !== void 0 ? _a : {};\n\n      if (this.isActive(state)) {\n        return setBlockType(schema.nodes.paragraph, attrs)(state, dispatch);\n      }\n\n      return setBlockType(type, Object.assign(Object.assign({}, attrs), {\n        level: this.level\n      }))(state, dispatch);\n    };\n  }\n\n  isActive(state) {\n    const {\n      schema\n    } = state;\n    const nodesInSelection = getSelectionNodes(state);\n    const type = schema.nodes.heading;\n\n    if (!type) {\n      return false;\n    }\n\n    const supportedNodes = [type, schema.nodes.text, schema.nodes.blockquote]; // heading is a text node\n    // don't mark as active when it has more nodes\n\n    const nodes = nodesInSelection.filter(node => {\n      return supportedNodes.includes(node.type);\n    });\n    const acitveNode = nodes.find(node => {\n      return node.attrs.level === this.level;\n    });\n    return Boolean(acitveNode);\n  }\n\n  canExecute(state) {\n    return this.toggle()(state);\n  }\n\n}\n\nclass TextAlign {\n  constructor(align) {\n    this.align = align;\n  }\n\n  toggle() {\n    return (state, dispatch) => {\n      const {\n        doc,\n        selection,\n        tr,\n        schema\n      } = state;\n      const {\n        from,\n        to\n      } = selection;\n      let applicable = false;\n      doc.nodesBetween(from, to, (node, pos) => {\n        const nodeType = node.type;\n\n        if ([schema.nodes.paragraph, schema.nodes.heading].includes(nodeType)) {\n          applicable = true;\n          tr.setNodeMarkup(pos, nodeType, Object.assign(Object.assign({}, node.attrs), {\n            align: this.align\n          }));\n        }\n\n        return true;\n      });\n\n      if (!applicable) {\n        return false;\n      }\n\n      if (tr.docChanged) {\n        dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);\n      }\n\n      return true;\n    };\n  }\n\n  isActive(state) {\n    const nodes = getSelectionNodes(state);\n    const active = nodes.find(node => {\n      return node.attrs.align === this.align;\n    });\n    return Boolean(active);\n  }\n\n  canExecute(state) {\n    return this.toggle()(state);\n  }\n\n}\n\nconst defaultOptions = {\n  strict: true\n};\n\nclass Link$1 {\n  update(attrs = {}) {\n    return (state, dispatch) => {\n      const {\n        schema,\n        selection\n      } = state;\n      const type = schema.marks.link;\n\n      if (!type) {\n        return false;\n      }\n\n      if (selection.empty) {\n        return false;\n      }\n\n      return toggleMark(type, attrs)(state, dispatch);\n    };\n  }\n\n  insert(text, attrs) {\n    return (state, dispatch) => {\n      var _a, _b;\n\n      const {\n        schema,\n        tr\n      } = state;\n      const type = schema.marks.link;\n\n      if (!type) {\n        return false;\n      }\n\n      const linkAttrs = {\n        href: attrs.href,\n        title: (_a = attrs.title) !== null && _a !== void 0 ? _a : text,\n        target: (_b = attrs.target) !== null && _b !== void 0 ? _b : '_blank'\n      };\n      const node = schema.text(text, [schema.marks.link.create(linkAttrs)]);\n      tr.replaceSelectionWith(node, false).scrollIntoView();\n\n      if (tr.docChanged) {\n        dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);\n        return true;\n      }\n\n      return false;\n    };\n  }\n\n  isActive(state, options = defaultOptions) {\n    if (options.strict) {\n      return true;\n    }\n\n    const {\n      schema\n    } = state;\n    const type = schema.marks.link;\n\n    if (!type) {\n      return false;\n    }\n\n    return isMarkActive(state, type);\n  }\n\n  remove(state, dispatch) {\n    return removeLink()(state, dispatch);\n  }\n\n  canExecute(state) {\n    return this.update({})(state);\n  }\n\n}\n\nclass Image$1 {\n  insert(src, attrs) {\n    return (state, dispatch) => {\n      const {\n        schema,\n        tr,\n        selection\n      } = state;\n      const type = schema.nodes.image;\n\n      if (!type) {\n        return false;\n      }\n\n      const imageAttrs = Object.assign({\n        width: null,\n        src\n      }, attrs);\n\n      if (!imageAttrs.width && selection instanceof NodeSelection && selection.node.type === type) {\n        imageAttrs.width = selection.node.attrs.width;\n      }\n\n      tr.replaceSelectionWith(type.createAndFill(imageAttrs));\n      const resolvedPos = tr.doc.resolve(tr.selection.anchor - tr.selection.$anchor.nodeBefore.nodeSize);\n      tr.setSelection(new NodeSelection(resolvedPos)).scrollIntoView();\n\n      if (tr.docChanged) {\n        dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);\n        return true;\n      }\n\n      return false;\n    };\n  }\n\n  isActive(state) {\n    const {\n      selection\n    } = state;\n\n    if (selection instanceof NodeSelection) {\n      return selection.node.type.name === 'image';\n    }\n\n    return false;\n  }\n\n}\n\nclass TextColor$1 {\n  constructor(name) {\n    this.name = name;\n  }\n\n  apply(attrs) {\n    return (state, dispatch) => {\n      const {\n        schema,\n        selection,\n        doc\n      } = state;\n      const type = schema.marks[this.name];\n\n      if (!type) {\n        return false;\n      }\n\n      const {\n        from,\n        to,\n        empty\n      } = selection;\n\n      if (!empty && from + 1 === to) {\n        const node = doc.nodeAt(from);\n\n        if ((node === null || node === void 0 ? void 0 : node.isAtom) && !node.isText && node.isLeaf) {\n          // An atomic node (e.g. Image) is selected.\n          return false;\n        }\n      }\n\n      return applyMark(type, attrs)(state, dispatch);\n    };\n  }\n\n  isActive(state) {\n    const {\n      schema\n    } = state;\n    const type = schema.marks[this.name];\n\n    if (!type) {\n      return false;\n    }\n\n    return isMarkActive(state, type);\n  }\n\n  getActiveColors(state) {\n    if (!this.isActive(state)) {\n      return [];\n    }\n\n    const {\n      schema\n    } = state;\n    const marks = getSelectionMarks(state);\n    const colors = marks.filter(mark => mark.type === schema.marks[this.name]).map(mark => mark.attrs.color).filter(Boolean);\n    return colors;\n  }\n\n  remove() {\n    return (state, dispatch) => {\n      const {\n        schema\n      } = state;\n      const type = schema.marks[this.name];\n\n      if (!type) {\n        return false;\n      }\n\n      return removeMark(type)(state, dispatch);\n    };\n  }\n\n  canExecute(state) {\n    const attrs = this.name === 'text_color' ? {\n      color: ''\n    } : {\n      backgroundColor: ''\n    };\n    return this.apply(attrs)(state);\n  }\n\n}\n\nconst STRONG = new Mark('strong');\nconst EM = new Mark('em');\nconst CODE = new Mark('code');\nconst UNDERLINE = new Mark('u');\nconst STRIKE = new Mark('s');\nconst BLOCKQUOTE = new Blockqote();\nconst UL = new ListItem(true);\nconst OL = new ListItem(false);\nconst H1 = new Heading(1);\nconst H2 = new Heading(2);\nconst H3 = new Heading(3);\nconst H4 = new Heading(4);\nconst H5 = new Heading(5);\nconst H6 = new Heading(6);\nconst ALIGN_LEFT = new TextAlign('left');\nconst ALIGN_CENTER = new TextAlign('center');\nconst ALIGN_RIGHT = new TextAlign('right');\nconst ALIGN_JUSTIFY = new TextAlign('justify');\nconst LINK = new Link$1();\nconst IMAGE = new Image$1();\nconst TEXT_COLOR = new TextColor$1('text_color');\nconst TEXT_BACKGROUND_COLOR = new TextColor$1('text_background_color');\nconst ToggleCommands = {\n  bold: STRONG,\n  italic: EM,\n  code: CODE,\n  underline: UNDERLINE,\n  strike: STRIKE,\n  blockquote: BLOCKQUOTE,\n  bullet_list: UL,\n  ordered_list: OL,\n  h1: H1,\n  h2: H2,\n  h3: H3,\n  h4: H4,\n  h5: H5,\n  h6: H6,\n  align_left: ALIGN_LEFT,\n  align_center: ALIGN_CENTER,\n  align_right: ALIGN_RIGHT,\n  align_justify: ALIGN_JUSTIFY\n};\nconst Link = LINK;\nconst Image = IMAGE;\nconst TextColor = TEXT_COLOR;\nconst TextBackgroundColor = TEXT_BACKGROUND_COLOR;\nconst defaults = {\n  // menu\n  bold: 'Bold',\n  italic: 'Italic',\n  code: 'Code',\n  underline: 'Underline',\n  strike: 'Strike',\n  blockquote: 'Blockquote',\n  bullet_list: 'Bullet List',\n  ordered_list: 'Ordered List',\n  heading: 'Heading',\n  h1: 'Header 1',\n  h2: 'Header 2',\n  h3: 'Header 3',\n  h4: 'Header 4',\n  h5: 'Header 5',\n  h6: 'Header 6',\n  align_left: 'Left Align',\n  align_center: 'Center Align',\n  align_right: 'Right Align',\n  align_justify: 'Justify',\n  text_color: 'Text Color',\n  background_color: 'Background Color',\n  insertLink: 'Insert Link',\n  removeLink: 'Remove Link',\n  insertImage: 'Insert Image',\n  // pupups, forms, others...\n  url: 'URL',\n  text: 'Text',\n  openInNewTab: 'Open in new tab',\n  insert: 'Insert',\n  altText: 'Alt Text',\n  title: 'Title',\n  remove: 'Remove'\n};\n\nclass Locals {\n  constructor(newLocals = {}) {\n    this.locals = defaults;\n\n    this.get = key => {\n      var _a;\n\n      return (_a = this.locals[key]) !== null && _a !== void 0 ? _a : '';\n    };\n\n    this.locals = Object.assign({}, defaults, newLocals);\n  }\n\n}\n\nlet NgxEditorServiceConfig = /*@__PURE__*/(() => {\n  class NgxEditorServiceConfig {\n    constructor() {\n      this.locals = {};\n    }\n\n  }\n\n  NgxEditorServiceConfig.ɵfac = function NgxEditorServiceConfig_Factory(t) {\n    return new (t || NgxEditorServiceConfig)();\n  };\n\n  NgxEditorServiceConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxEditorServiceConfig,\n    factory: NgxEditorServiceConfig.ɵfac,\n    providedIn: 'root'\n  });\n  return NgxEditorServiceConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxEditorServiceConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\nlet NgxEditorService = /*@__PURE__*/(() => {\n  class NgxEditorService {\n    constructor(config) {\n      this.config = config;\n    }\n\n    get locals() {\n      return new Locals(this.config.locals);\n    }\n\n  }\n\n  NgxEditorService.ɵfac = function NgxEditorService_Factory(t) {\n    return new (t || NgxEditorService)(i0.ɵɵinject(NgxEditorServiceConfig, 8));\n  };\n\n  NgxEditorService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxEditorService,\n    factory: NgxEditorService.ɵfac,\n    providedIn: 'root'\n  });\n  return NgxEditorService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxEditorService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: NgxEditorServiceConfig,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\nconst provideMyServiceOptions = config => {\n  var _a;\n\n  return {\n    locals: (_a = config.locals) !== null && _a !== void 0 ? _a : {}\n  };\n};\n\nlet SanitizeHtmlPipe = /*@__PURE__*/(() => {\n  class SanitizeHtmlPipe {\n    constructor(sanitizer) {\n      this.sanitizer = sanitizer;\n    }\n\n    transform(value) {\n      return this.sanitizer.bypassSecurityTrustHtml(value);\n    }\n\n  }\n\n  SanitizeHtmlPipe.ɵfac = function SanitizeHtmlPipe_Factory(t) {\n    return new (t || SanitizeHtmlPipe)(i0.ɵɵdirectiveInject(i1.DomSanitizer, 16));\n  };\n\n  SanitizeHtmlPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"sanitizeHtml\",\n    type: SanitizeHtmlPipe,\n    pure: true\n  });\n  return SanitizeHtmlPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SanitizeHtmlPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'sanitizeHtml'\n    }]\n  }], function () {\n    return [{\n      type: i1.DomSanitizer\n    }];\n  }, null);\n})();\n\nlet ToggleCommandComponent = /*@__PURE__*/(() => {\n  class ToggleCommandComponent {\n    constructor(ngxeService, menuService) {\n      this.ngxeService = ngxeService;\n      this.menuService = menuService;\n      this.isActive = false;\n      this.disabled = false;\n\n      this.update = view => {\n        const {\n          state\n        } = view;\n        const command = ToggleCommands[this.name];\n        this.isActive = command.isActive(state);\n        this.disabled = !command.canExecute(state);\n      };\n    }\n\n    get name() {\n      return this.toolbarItem;\n    }\n\n    toggle(e) {\n      e.preventDefault();\n\n      if (e.button !== 0) {\n        return;\n      }\n\n      const {\n        state,\n        dispatch\n      } = this.editorView;\n      const command = ToggleCommands[this.name];\n      command.toggle()(state, dispatch);\n    }\n\n    getTitle(name) {\n      return this.ngxeService.locals.get(name);\n    }\n\n    ngOnInit() {\n      this.html = Icon.get(this.name);\n      this.editorView = this.menuService.editor.view;\n      this.updateSubscription = this.menuService.editor.update.subscribe(view => {\n        this.update(view);\n      });\n    }\n\n    ngOnDestroy() {\n      this.updateSubscription.unsubscribe();\n    }\n\n  }\n\n  ToggleCommandComponent.ɵfac = function ToggleCommandComponent_Factory(t) {\n    return new (t || ToggleCommandComponent)(i0.ɵɵdirectiveInject(NgxEditorService), i0.ɵɵdirectiveInject(MenuService));\n  };\n\n  ToggleCommandComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToggleCommandComponent,\n    selectors: [[\"ngx-toggle-command\"]],\n    hostVars: 4,\n    hostBindings: function ToggleCommandComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"NgxEditor__MenuItem--Active\", ctx.isActive)(\"NgxEditor--Disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      toolbarItem: \"toolbarItem\"\n    },\n    decls: 2,\n    vars: 4,\n    consts: [[1, \"NgxEditor__MenuItem--IconContainer\", 3, \"innerHTML\", \"title\", \"mousedown\"]],\n    template: function ToggleCommandComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"mousedown\", function ToggleCommandComponent_Template_div_mousedown_0_listener($event) {\n          return ctx.toggle($event);\n        });\n        i0.ɵɵpipe(1, \"sanitizeHtml\");\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", i0.ɵɵpipeBind1(1, 2, ctx.html), i0.ɵɵsanitizeHtml)(\"title\", ctx.getTitle(ctx.name));\n      }\n    },\n    pipes: [SanitizeHtmlPipe],\n    styles: [\"\"]\n  });\n  return ToggleCommandComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ToggleCommandComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-toggle-command',\n      templateUrl: './toggle-command.component.html',\n      styleUrls: ['./toggle-command.component.scss']\n    }]\n  }], function () {\n    return [{\n      type: NgxEditorService\n    }, {\n      type: MenuService\n    }];\n  }, {\n    toolbarItem: [{\n      type: Input\n    }],\n    isActive: [{\n      type: HostBinding,\n      args: ['class.NgxEditor__MenuItem--Active']\n    }],\n    disabled: [{\n      type: HostBinding,\n      args: ['class.NgxEditor--Disabled']\n    }]\n  });\n})();\n\nlet LinkComponent = /*@__PURE__*/(() => {\n  class LinkComponent {\n    constructor(el, ngxeService, menuService) {\n      this.el = el;\n      this.ngxeService = ngxeService;\n      this.menuService = menuService;\n      this.showPopup = false;\n      this.isActive = false;\n      this.canExecute = true;\n      this.form = new FormGroup({\n        href: new FormControl('', [Validators$1.required, Validators$1.pattern('(https?://)?([\\\\da-z.-]+)\\\\.([a-z.]{2,6})[/\\\\w .-]*/??([^#\\n\\r]*)?#?([^\\n\\r]*)')]),\n        text: new FormControl('', [Validators$1.required]),\n        openInNewTab: new FormControl(true)\n      });\n\n      this.setText = () => {\n        const {\n          state: {\n            selection,\n            doc\n          }\n        } = this.editorView;\n        const {\n          empty,\n          from,\n          to\n        } = selection;\n        const selectedText = !empty ? doc.textBetween(from, to) : '';\n\n        if (selectedText) {\n          this.text.patchValue(selectedText);\n          this.text.disable();\n        }\n      };\n\n      this.update = view => {\n        const {\n          state\n        } = view;\n        this.isActive = Link.isActive(state, {\n          strict: false\n        });\n        this.canExecute = Link.canExecute(state);\n      };\n    }\n\n    get valid() {\n      return this.isActive || this.showPopup;\n    }\n\n    get disabled() {\n      return !this.canExecute;\n    }\n\n    get icon() {\n      return Icon.get(this.isActive ? 'unlink' : 'link');\n    }\n\n    get title() {\n      return this.ngxeService.locals.get(this.isActive ? 'removeLink' : 'insertLink');\n    }\n\n    get href() {\n      return this.form.get('href');\n    }\n\n    get text() {\n      return this.form.get('text');\n    }\n\n    onDocumentClick(e) {\n      if (!this.el.nativeElement.contains(e.target) && this.showPopup) {\n        this.hideForm();\n      }\n    }\n\n    getLabel(key) {\n      return this.ngxeService.locals.get(key);\n    }\n\n    hideForm() {\n      this.showPopup = false;\n      this.form.reset({\n        href: '',\n        text: '',\n        openInNewTab: true\n      });\n      this.text.enable();\n    }\n\n    onMouseDown(e) {\n      e.preventDefault();\n\n      if (e.button !== 0) {\n        return;\n      }\n\n      const {\n        state,\n        dispatch\n      } = this.editorView;\n\n      if (this.isActive) {\n        Link.remove(state, dispatch);\n        return;\n      }\n\n      this.showPopup = !this.showPopup;\n\n      if (this.showPopup) {\n        this.setText();\n      }\n    }\n\n    insertLink(e) {\n      e.preventDefault();\n      const {\n        text,\n        href,\n        openInNewTab\n      } = this.form.getRawValue();\n      const {\n        dispatch,\n        state\n      } = this.editorView;\n      const {\n        selection\n      } = state;\n      const attrs = {\n        title: href,\n        href,\n        target: openInNewTab ? '_blank' : '_self'\n      };\n\n      if (selection.empty) {\n        Link.insert(text, attrs)(state, dispatch);\n        this.editorView.focus();\n      } else {\n        Link.update(attrs)(state, dispatch);\n      }\n\n      this.hideForm();\n    }\n\n    ngOnInit() {\n      this.editorView = this.menuService.editor.view;\n      this.updateSubscription = this.menuService.editor.update.subscribe(view => {\n        this.update(view);\n      });\n    }\n\n    ngOnDestroy() {\n      this.updateSubscription.unsubscribe();\n    }\n\n  }\n\n  LinkComponent.ɵfac = function LinkComponent_Factory(t) {\n    return new (t || LinkComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NgxEditorService), i0.ɵɵdirectiveInject(MenuService));\n  };\n\n  LinkComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LinkComponent,\n    selectors: [[\"ngx-link\"]],\n    hostVars: 4,\n    hostBindings: function LinkComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function LinkComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onDocumentClick($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"NgxEditor__MenuItem--Active\", ctx.valid)(\"NgxEditor--Disabled\", ctx.disabled);\n      }\n    },\n    decls: 3,\n    vars: 5,\n    consts: [[1, \"NgxEditor__MenuItem--IconContainer\", 3, \"innerHTML\", \"title\", \"mousedown\"], [\"class\", \"NgxEditor__Popup\", 4, \"ngIf\"], [1, \"NgxEditor__Popup\"], [1, \"NgxEditor__Popup--Form\", 3, \"formGroup\", \"ngSubmit\"], [1, \"NgxEditor__Popup--FormGroup\"], [1, \"NgxEditor__Popup--Col\"], [1, \"NgxEditor__Popup--Label\"], [\"type\", \"href\", \"id\", \"href\", \"formControlName\", \"href\", \"autofocus\", \"\", \"autocomplete\", \"off\"], [\"class\", \"NgxEditor__HelpText NgxEditor__HelpText--Error\", 4, \"ngIf\"], [\"type\", \"text\", \"formControlName\", \"text\", \"autocomplete\", \"off\"], [\"type\", \"checkbox\", \"formControlName\", \"openInNewTab\"], [\"type\", \"submit\", 3, \"disabled\"], [1, \"NgxEditor__HelpText\", \"NgxEditor__HelpText--Error\"]],\n    template: function LinkComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"mousedown\", function LinkComponent_Template_div_mousedown_0_listener($event) {\n          return ctx.onMouseDown($event);\n        });\n        i0.ɵɵpipe(1, \"sanitizeHtml\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, LinkComponent_div_2_Template, 21, 8, \"div\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", i0.ɵɵpipeBind1(1, 3, ctx.icon), i0.ɵɵsanitizeHtml)(\"title\", ctx.title);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showPopup);\n      }\n    },\n    directives: [i3.NgIf, i4.ɵNgNoValidate, i4.NgControlStatusGroup, i4.FormGroupDirective, i4.DefaultValueAccessor, i4.NgControlStatus, i4.FormControlName, i4.CheckboxControlValueAccessor],\n    pipes: [SanitizeHtmlPipe],\n    styles: [\"\"]\n  });\n  return LinkComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LinkComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-link',\n      templateUrl: './link.component.html',\n      styleUrls: ['./link.component.scss']\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: NgxEditorService\n    }, {\n      type: MenuService\n    }];\n  }, {\n    valid: [{\n      type: HostBinding,\n      args: ['class.NgxEditor__MenuItem--Active']\n    }],\n    disabled: [{\n      type: HostBinding,\n      args: ['class.NgxEditor--Disabled']\n    }],\n    onDocumentClick: [{\n      type: HostListener,\n      args: ['document:mousedown', ['$event']]\n    }]\n  });\n})();\n\nlet ImageComponent = /*@__PURE__*/(() => {\n  class ImageComponent {\n    constructor(el, ngxeService, menuService) {\n      this.el = el;\n      this.ngxeService = ngxeService;\n      this.menuService = menuService;\n      this.showPopup = false;\n      this.isActive = false;\n      this.form = new FormGroup({\n        src: new FormControl('', [Validators$1.required, Validators$1.pattern('(https?://)?([\\\\da-z.-]+)\\\\.([a-z.]{2,6})[/\\\\w .-]*/??([^#\\n\\r]*)?#?([^\\n\\r]*)')]),\n        alt: new FormControl(''),\n        title: new FormControl('')\n      });\n\n      this.update = view => {\n        const {\n          state\n        } = view;\n        this.isActive = Image.isActive(state);\n      };\n    }\n\n    get valid() {\n      return this.isActive || this.showPopup;\n    }\n\n    get icon() {\n      return Icon.get('image');\n    }\n\n    get src() {\n      return this.form.get('src');\n    }\n\n    onDocumentClick(e) {\n      if (!this.el.nativeElement.contains(e.target) && this.showPopup) {\n        this.hideForm();\n      }\n    }\n\n    getLabel(key) {\n      return this.ngxeService.locals.get(key);\n    }\n\n    hideForm() {\n      this.showPopup = false;\n      this.form.reset({\n        src: '',\n        alt: '',\n        title: ''\n      });\n    }\n\n    onMouseDown(e) {\n      e.preventDefault();\n\n      if (e.button !== 0) {\n        return;\n      }\n\n      this.showPopup = !this.showPopup;\n\n      if (this.showPopup) {\n        this.fillForm();\n      }\n    }\n\n    fillForm() {\n      const {\n        state\n      } = this.editorView;\n      const {\n        selection\n      } = state;\n\n      if (selection instanceof NodeSelection && this.isActive) {\n        const {\n          src,\n          alt = '',\n          title = ''\n        } = selection.node.attrs;\n        this.form.setValue({\n          src,\n          alt,\n          title\n        });\n      }\n    }\n\n    insertLink(e) {\n      e.preventDefault();\n      const {\n        src,\n        alt,\n        title\n      } = this.form.getRawValue();\n      const {\n        dispatch,\n        state\n      } = this.editorView;\n      const attrs = {\n        alt,\n        title\n      };\n      Image.insert(src, attrs)(state, dispatch);\n      this.editorView.focus();\n      this.hideForm();\n    }\n\n    ngOnInit() {\n      this.editorView = this.menuService.editor.view;\n      this.updateSubscription = this.menuService.editor.update.subscribe(view => {\n        this.update(view);\n      });\n    }\n\n    ngOnDestroy() {\n      this.updateSubscription.unsubscribe();\n    }\n\n  }\n\n  ImageComponent.ɵfac = function ImageComponent_Factory(t) {\n    return new (t || ImageComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NgxEditorService), i0.ɵɵdirectiveInject(MenuService));\n  };\n\n  ImageComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ImageComponent,\n    selectors: [[\"ngx-image\"]],\n    hostVars: 2,\n    hostBindings: function ImageComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function ImageComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onDocumentClick($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"NgxEditor__MenuItem--Active\", ctx.valid);\n      }\n    },\n    decls: 3,\n    vars: 5,\n    consts: [[1, \"NgxEditor__MenuItem--IconContainer\", 3, \"innerHTML\", \"title\", \"mousedown\"], [\"class\", \"NgxEditor__Popup\", 4, \"ngIf\"], [1, \"NgxEditor__Popup\"], [1, \"NgxEditor__Popup--Form\", 3, \"formGroup\", \"ngSubmit\"], [1, \"NgxEditor__Popup--FormGroup\"], [1, \"NgxEditor__Popup--Col\"], [1, \"NgxEditor__Popup--Label\"], [\"type\", \"href\", \"id\", \"href\", \"formControlName\", \"src\", \"autofocus\", \"\", \"autocomplete\", \"off\"], [\"class\", \"NgxEditor__HelpText NgxEditor__HelpText--Error\", 4, \"ngIf\"], [\"type\", \"text\", \"formControlName\", \"alt\", \"autocomplete\", \"off\"], [\"type\", \"text\", \"formControlName\", \"title\", \"autocomplete\", \"off\"], [\"type\", \"submit\", 3, \"disabled\"], [1, \"NgxEditor__HelpText\", \"NgxEditor__HelpText--Error\"]],\n    template: function ImageComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"mousedown\", function ImageComponent_Template_div_mousedown_0_listener($event) {\n          return ctx.onMouseDown($event);\n        });\n        i0.ɵɵpipe(1, \"sanitizeHtml\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, ImageComponent_div_2_Template, 20, 7, \"div\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", i0.ɵɵpipeBind1(1, 3, ctx.icon), i0.ɵɵsanitizeHtml)(\"title\", ctx.getLabel(\"insertImage\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showPopup);\n      }\n    },\n    directives: [i3.NgIf, i4.ɵNgNoValidate, i4.NgControlStatusGroup, i4.FormGroupDirective, i4.DefaultValueAccessor, i4.NgControlStatus, i4.FormControlName],\n    pipes: [SanitizeHtmlPipe],\n    styles: [\"\"]\n  });\n  return ImageComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImageComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-image',\n      templateUrl: './image.component.html',\n      styleUrls: ['./image.component.scss']\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: NgxEditorService\n    }, {\n      type: MenuService\n    }];\n  }, {\n    valid: [{\n      type: HostBinding,\n      args: ['class.NgxEditor__MenuItem--Active']\n    }],\n    onDocumentClick: [{\n      type: HostListener,\n      args: ['document:mousedown', ['$event']]\n    }]\n  });\n})();\n\nlet DropdownComponent = /*@__PURE__*/(() => {\n  class DropdownComponent {\n    constructor(ngxeService, menuService, el) {\n      this.ngxeService = ngxeService;\n      this.menuService = menuService;\n      this.el = el;\n      this.isDropdownOpen = false;\n      this.activeItems = [];\n      this.disabledItems = [];\n\n      this.update = view => {\n        const {\n          state\n        } = view;\n        this.activeItems = [];\n        this.disabledItems = [];\n        this.items.forEach(item => {\n          const command = ToggleCommands[item];\n          const isActive = command.isActive(state);\n\n          if (isActive) {\n            this.activeItems.push(item);\n          }\n\n          if (!command.canExecute(state)) {\n            this.disabledItems.push(item);\n          }\n        });\n\n        if (this.activeItems.length === 1) {\n          this.activeItem = this.activeItems[0];\n        } else {\n          this.activeItem = null;\n        }\n      };\n    }\n\n    get isSelected() {\n      return Boolean(this.activeItem || this.isDropdownOpen);\n    }\n\n    get isDropdownDisabled() {\n      return this.disabledItems.length === this.items.length;\n    }\n\n    onDocumentClick(target) {\n      if (!this.el.nativeElement.contains(target) && this.isDropdownOpen) {\n        this.isDropdownOpen = false;\n      }\n    }\n\n    getName(key) {\n      return this.ngxeService.locals.get(key);\n    }\n\n    toggleDropdown(e) {\n      e.preventDefault();\n      this.isDropdownOpen = !this.isDropdownOpen;\n    }\n\n    onClick(e, item) {\n      e.preventDefault(); // consider only left click\n\n      if (e.button !== 0) {\n        return;\n      }\n\n      const command = ToggleCommands[item];\n      const {\n        state,\n        dispatch\n      } = this.editorView;\n      command.toggle()(state, dispatch);\n      this.isDropdownOpen = false;\n    }\n\n    ngOnInit() {\n      this.editorView = this.menuService.editor.view;\n      this.updateSubscription = this.menuService.editor.update.subscribe(view => {\n        this.update(view);\n      });\n    }\n\n    ngOnDestroy() {\n      this.updateSubscription.unsubscribe();\n    }\n\n  }\n\n  DropdownComponent.ɵfac = function DropdownComponent_Factory(t) {\n    return new (t || DropdownComponent)(i0.ɵɵdirectiveInject(NgxEditorService), i0.ɵɵdirectiveInject(MenuService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  DropdownComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DropdownComponent,\n    selectors: [[\"ngx-dropdown\"]],\n    hostVars: 4,\n    hostBindings: function DropdownComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function DropdownComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onDocumentClick($event.target);\n        }, false, i0.ɵɵresolveDocument);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"NgxEditor__Dropdown--Selected\", ctx.isSelected)(\"NgxEditor--Disabled\", ctx.isDropdownDisabled);\n      }\n    },\n    inputs: {\n      group: \"group\",\n      items: \"items\"\n    },\n    decls: 3,\n    vars: 2,\n    consts: [[1, \"NgxEditor__Dropdown--Text\", 3, \"mousedown\"], [\"class\", \"NgxEditor__Dropdown--DropdownMenu\", 4, \"ngIf\"], [1, \"NgxEditor__Dropdown--DropdownMenu\"], [\"class\", \"NgxEditor__Dropdown--Item\", 3, \"ngClass\", \"mousedown\", 4, \"ngFor\", \"ngForOf\"], [1, \"NgxEditor__Dropdown--Item\", 3, \"ngClass\", \"mousedown\"]],\n    template: function DropdownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"mousedown\", function DropdownComponent_Template_div_mousedown_0_listener($event) {\n          return ctx.toggleDropdown($event);\n        });\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, DropdownComponent_div_2_Template, 2, 1, \"div\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.getName(ctx.activeItem || ctx.group), \"\\n\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isDropdownOpen);\n      }\n    },\n    directives: [i3.NgIf, i3.NgForOf, i3.NgClass],\n    styles: [\"\"]\n  });\n  return DropdownComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DropdownComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-dropdown',\n      templateUrl: './dropdown.component.html',\n      styleUrls: ['./dropdown.component.scss']\n    }]\n  }], function () {\n    return [{\n      type: NgxEditorService\n    }, {\n      type: MenuService\n    }, {\n      type: i0.ElementRef\n    }];\n  }, {\n    group: [{\n      type: Input\n    }],\n    items: [{\n      type: Input\n    }],\n    isSelected: [{\n      type: HostBinding,\n      args: ['class.NgxEditor__Dropdown--Selected']\n    }],\n    isDropdownDisabled: [{\n      type: HostBinding,\n      args: ['class.NgxEditor--Disabled']\n    }],\n    onDocumentClick: [{\n      type: HostListener,\n      args: ['document:mousedown', ['$event.target']]\n    }]\n  });\n})();\n\nlet ColorPickerComponent = /*@__PURE__*/(() => {\n  class ColorPickerComponent {\n    constructor(el, menuService, ngxeService) {\n      this.el = el;\n      this.menuService = menuService;\n      this.ngxeService = ngxeService;\n      this.showPopup = false;\n      this.isActive = false;\n      this.activeColors = [];\n      this.canExecute = true;\n\n      this.update = view => {\n        const {\n          state\n        } = view;\n        this.canExecute = this.command.canExecute(state);\n        this.isActive = this.command.isActive(state);\n        this.activeColors = [];\n\n        if (this.isActive) {\n          this.activeColors = this.command.getActiveColors(state);\n        }\n      };\n    }\n\n    get valid() {\n      return this.isActive || this.showPopup;\n    }\n\n    get disabled() {\n      return !this.canExecute;\n    }\n\n    get title() {\n      return this.getLabel(this.type === 'text_color' ? 'text_color' : 'background_color');\n    }\n\n    get icon() {\n      return Icon.get(this.type === 'text_color' ? 'text_color' : 'color_fill');\n    }\n\n    get command() {\n      return this.type === 'text_color' ? TextColor : TextBackgroundColor;\n    }\n\n    getContrastYIQ(hexcolor) {\n      hexcolor = hexcolor.replace('#', '');\n      const r = parseInt(hexcolor.substr(0, 2), 16);\n      const g = parseInt(hexcolor.substr(2, 2), 16);\n      const b = parseInt(hexcolor.substr(4, 2), 16);\n      const yiq = (r * 299 + g * 587 + b * 114) / 1000;\n      return yiq >= 128 ? 'black' : 'white';\n    }\n\n    onDocumentClick(e) {\n      if (!this.el.nativeElement.contains(e.target) && this.showPopup) {\n        this.hidePopup();\n      }\n    }\n\n    hidePopup() {\n      this.showPopup = false;\n    }\n\n    togglePopup(e) {\n      e.preventDefault();\n\n      if (e.button !== 0) {\n        return;\n      }\n\n      this.showPopup = !this.showPopup;\n    }\n\n    remove(e) {\n      e.preventDefault();\n      const {\n        state,\n        dispatch\n      } = this.editorView;\n      this.command.remove()(state, dispatch);\n      this.hidePopup();\n    }\n\n    onColorSelect(e, color) {\n      e.preventDefault();\n\n      if (e.button !== 0) {\n        return;\n      }\n\n      const {\n        state,\n        dispatch\n      } = this.editorView;\n\n      if (this.type === 'text_color') {\n        const attrs = {\n          color\n        };\n        this.command.apply(attrs)(state, dispatch);\n      } else {\n        const attrs = {\n          backgroundColor: color\n        };\n        this.command.apply(attrs)(state, dispatch);\n      }\n\n      if (!this.editorView.hasFocus()) {\n        this.editorView.focus();\n      }\n\n      this.hidePopup();\n    }\n\n    getLabel(key) {\n      return this.ngxeService.locals.get(key);\n    }\n\n    ngOnInit() {\n      this.editorView = this.menuService.editor.view;\n      this.updateSubscription = this.menuService.editor.update.subscribe(view => {\n        this.update(view);\n      });\n    }\n\n    ngOnDestroy() {\n      this.updateSubscription.unsubscribe();\n    }\n\n  }\n\n  ColorPickerComponent.ɵfac = function ColorPickerComponent_Factory(t) {\n    return new (t || ColorPickerComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(MenuService), i0.ɵɵdirectiveInject(NgxEditorService));\n  };\n\n  ColorPickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColorPickerComponent,\n    selectors: [[\"ngx-color-picker\"]],\n    hostVars: 4,\n    hostBindings: function ColorPickerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function ColorPickerComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onDocumentClick($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"NgxEditor__MenuItem--Active\", ctx.valid)(\"NgxEditor--Disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      presets: \"presets\",\n      type: \"type\"\n    },\n    decls: 3,\n    vars: 5,\n    consts: [[1, \"NgxEditor__MenuItem--IconContainer\", 3, \"innerHTML\", \"title\", \"mousedown\"], [\"class\", \"NgxEditor__Popup\", 4, \"ngIf\"], [1, \"NgxEditor__Popup\"], [\"class\", \"NgxEditor__ColorContainer\", 4, \"ngFor\", \"ngForOf\"], [1, \"NgxEditor__MenuItem--Button\", 3, \"disabled\", \"mousedown\"], [1, \"NgxEditor__ColorContainer\"], [\"class\", \"NgxEditor__Color\", 3, \"ngStyle\", \"title\", \"ngClass\", \"mousedown\", 4, \"ngFor\", \"ngForOf\"], [1, \"NgxEditor__Color\", 3, \"ngStyle\", \"title\", \"ngClass\", \"mousedown\"]],\n    template: function ColorPickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"mousedown\", function ColorPickerComponent_Template_div_mousedown_0_listener($event) {\n          return ctx.togglePopup($event);\n        });\n        i0.ɵɵpipe(1, \"sanitizeHtml\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, ColorPickerComponent_div_2_Template, 4, 3, \"div\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", i0.ɵɵpipeBind1(1, 3, ctx.icon), i0.ɵɵsanitizeHtml)(\"title\", ctx.title);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showPopup);\n      }\n    },\n    directives: [i3.NgIf, i3.NgForOf, i3.NgStyle, i3.NgClass],\n    pipes: [SanitizeHtmlPipe],\n    styles: [\"@charset \\\"UTF-8\\\";.NgxEditor__Popup[_ngcontent-%COMP%]{width:230px}.NgxEditor__ColorContainer[_ngcontent-%COMP%]{display:flex;justify-content:space-between}.NgxEditor__ColorContainer[_ngcontent-%COMP%] + .NgxEditor__ColorContainer[_ngcontent-%COMP%]{margin-top:5px}.NgxEditor__Color[_ngcontent-%COMP%]{border:none;outline:none;border-radius:6px;width:24px;height:24px;flex-shrink:0}.NgxEditor__Color--Active[_ngcontent-%COMP%]:after{content:\\\"\\u2714\\\";font-size:90%}.NgxEditor__MenuItem--Button[_ngcontent-%COMP%]{margin-top:5px}\"]\n  });\n  return ColorPickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ColorPickerComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-color-picker',\n      templateUrl: './color-picker.component.html',\n      styleUrls: ['./color-picker.component.scss']\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: MenuService\n    }, {\n      type: NgxEditorService\n    }];\n  }, {\n    presets: [{\n      type: Input\n    }],\n    type: [{\n      type: Input\n    }],\n    valid: [{\n      type: HostBinding,\n      args: ['class.NgxEditor__MenuItem--Active']\n    }],\n    disabled: [{\n      type: HostBinding,\n      args: ['class.NgxEditor--Disabled']\n    }],\n    onDocumentClick: [{\n      type: HostListener,\n      args: ['document:mousedown', ['$event']]\n    }]\n  });\n})();\n\nconst DEFAULT_TOOLBAR = [['bold', 'italic'], ['code', 'blockquote'], ['underline', 'strike'], ['ordered_list', 'bullet_list'], [{\n  heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']\n}], ['link', 'image'], ['text_color', 'background_color'], ['align_left', 'align_center', 'align_right', 'align_justify']];\nconst DEFAULT_COLOR_PRESETS = ['#b60205', '#d93f0b', '#fbca04', '#0e8a16', '#006b75', '#1d76db', '#0052cc', '#5319e7', '#e99695', '#f9d0c4', '#fef2c0', '#c2e0c6', '#bfdadc', '#c5def5', '#bfd4f2', '#d4c5f9'];\n\nlet MenuComponent = /*@__PURE__*/(() => {\n  class MenuComponent {\n    constructor(menuService) {\n      this.menuService = menuService;\n      this.toolbar = DEFAULT_TOOLBAR;\n      this.colorPresets = DEFAULT_COLOR_PRESETS;\n      this.disabled = false;\n      this.customMenuRef = null;\n      this.dropdownPlacement = 'bottom';\n      this.toggleCommands = ['bold', 'italic', 'underline', 'strike', 'code', 'blockquote', 'ordered_list', 'bullet_list', 'align_left', 'align_center', 'align_right', 'align_justify'];\n      this.iconContainerClass = ['NgxEditor__MenuItem', 'NgxEditor__MenuItem--Icon'];\n      this.dropdownContainerClass = ['NgxEditor__Dropdown'];\n      this.seperatorClass = ['NgxEditor__Seperator'];\n    }\n\n    get presets() {\n      const col = 8;\n      const colors = [];\n      this.colorPresets.forEach((color, index) => {\n        const row = Math.floor(index / col);\n\n        if (!colors[row]) {\n          colors.push([]);\n        }\n\n        colors[row].push(color);\n      });\n      return colors;\n    }\n\n    isDropDown(item) {\n      var _a;\n\n      if ((_a = item) === null || _a === void 0 ? void 0 : _a.heading) {\n        return true;\n      }\n\n      return false;\n    }\n\n    getDropdownItems(item) {\n      return item;\n    }\n\n    ngOnInit() {\n      if (!this.editor) {\n        throw new Error('NgxEditor: Required editor instance');\n      }\n\n      this.menuService.editor = this.editor;\n    }\n\n  }\n\n  MenuComponent.ɵfac = function MenuComponent_Factory(t) {\n    return new (t || MenuComponent)(i0.ɵɵdirectiveInject(MenuService));\n  };\n\n  MenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MenuComponent,\n    selectors: [[\"ngx-editor-menu\"]],\n    inputs: {\n      toolbar: \"toolbar\",\n      colorPresets: \"colorPresets\",\n      disabled: \"disabled\",\n      editor: \"editor\",\n      customMenuRef: \"customMenuRef\",\n      dropdownPlacement: \"dropdownPlacement\"\n    },\n    features: [i0.ɵɵProvidersFeature([MenuService])],\n    decls: 3,\n    vars: 6,\n    consts: [[1, \"NgxEditor__MenuBar\", 3, \"ngClass\"], [4, \"ngFor\", \"ngForOf\"], [4, \"ngIf\"], [3, \"toolbarItem\", \"class\", 4, \"ngIf\"], [3, \"class\", 4, \"ngIf\"], [\"type\", \"text_color\", 3, \"class\", \"presets\", 4, \"ngIf\"], [\"type\", \"background_color\", 3, \"class\", \"presets\", 4, \"ngIf\"], [3, \"toolbarItem\"], [3, \"class\", \"group\", \"items\", 4, \"ngFor\", \"ngForOf\"], [3, \"group\", \"items\"], [\"type\", \"text_color\", 3, \"presets\"], [\"type\", \"background_color\", 3, \"presets\"], [3, \"ngTemplateOutlet\"]],\n    template: function MenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, MenuComponent_ng_container_1_Template, 2, 1, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, MenuComponent_ng_container_2_Template, 2, 1, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(3, _c7, ctx.disabled, ctx.dropdownPlacement === \"top\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.toolbar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.customMenuRef);\n      }\n    },\n    directives: [i3.NgClass, i3.NgForOf, i3.NgIf, ToggleCommandComponent, LinkComponent, ImageComponent, DropdownComponent, ColorPickerComponent, i3.NgTemplateOutlet],\n    pipes: [i3.KeyValuePipe],\n    styles: [\"\"]\n  });\n  return MenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MenuComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-editor-menu',\n      templateUrl: './menu.component.html',\n      styleUrls: ['./menu.component.scss'],\n      providers: [MenuService]\n    }]\n  }], function () {\n    return [{\n      type: MenuService\n    }];\n  }, {\n    toolbar: [{\n      type: Input\n    }],\n    colorPresets: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    editor: [{\n      type: Input\n    }],\n    customMenuRef: [{\n      type: Input\n    }],\n    dropdownPlacement: [{\n      type: Input\n    }]\n  });\n})();\n\nlet BubbleComponent = /*@__PURE__*/(() => {\n  class BubbleComponent {\n    constructor(sanitizeHTML, ngxeService) {\n      this.sanitizeHTML = sanitizeHTML;\n      this.ngxeService = ngxeService;\n      this.execulableItems = [];\n      this.activeItems = [];\n      this.toolbar = [['bold', 'italic', 'underline', 'strike'], ['ordered_list', 'bullet_list', 'blockquote', 'code'], ['align_left', 'align_center', 'align_right', 'align_justify']];\n      this.toggleCommands = ['bold', 'italic', 'underline', 'strike', 'ordered_list', 'bullet_list', 'blockquote', 'code', 'align_left', 'align_center', 'align_right', 'align_justify'];\n    }\n\n    get view() {\n      return this.editor.view;\n    }\n\n    getIcon(name) {\n      const icon = Icon.getPath(name);\n      return this.sanitizeHTML.transform(icon);\n    }\n\n    getTitle(name) {\n      return this.ngxeService.locals.get(name);\n    }\n\n    onClick(e, commandName) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (e.button !== 0) {\n        return;\n      }\n\n      const {\n        state,\n        dispatch\n      } = this.view;\n      const command = ToggleCommands[commandName];\n      command.toggle()(state, dispatch);\n    }\n\n    update(view) {\n      this.activeItems = [];\n      this.execulableItems = [];\n      const {\n        state\n      } = view;\n      this.toggleCommands.forEach(toolbarItem => {\n        const command = ToggleCommands[toolbarItem];\n        const isActive = command.isActive(state);\n\n        if (isActive) {\n          this.activeItems.push(toolbarItem);\n        }\n\n        const canExecute = command.canExecute(state);\n\n        if (canExecute) {\n          this.execulableItems.push(toolbarItem);\n        }\n      });\n    }\n\n    ngOnInit() {\n      this.updateSubscription = this.editor.update.subscribe(view => {\n        this.update(view);\n      });\n    }\n\n    ngOnDestroy() {\n      this.updateSubscription.unsubscribe();\n    }\n\n  }\n\n  BubbleComponent.ɵfac = function BubbleComponent_Factory(t) {\n    return new (t || BubbleComponent)(i0.ɵɵdirectiveInject(SanitizeHtmlPipe), i0.ɵɵdirectiveInject(NgxEditorService));\n  };\n\n  BubbleComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BubbleComponent,\n    selectors: [[\"ngx-bubble\"]],\n    inputs: {\n      editor: \"editor\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"class\", \"NgxBubbleMenu__Icon\", 3, \"ngClass\", \"title\", \"mousedown\", 4, \"ngIf\"], [\"class\", \"NgxBubbleMenu__Seperator\", 4, \"ngIf\"], [1, \"NgxBubbleMenu__Icon\", 3, \"ngClass\", \"title\", \"mousedown\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", \"viewBox\", \"0 0 24 24\", \"height\", \"20\", \"width\", \"20\", 3, \"innerHTML\"], [1, \"NgxBubbleMenu__Seperator\"]],\n    template: function BubbleComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, BubbleComponent_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.toolbar);\n      }\n    },\n    directives: [i3.NgForOf, i3.NgIf, i3.NgClass],\n    styles: [\"*[_ngcontent-%COMP%], [_ngcontent-%COMP%]:after, [_ngcontent-%COMP%]:before{box-sizing:border-box}[_nghost-%COMP%]{display:flex;background-color:#000;color:#fff;padding:.3rem;border-radius:4px}.NgxBubbleMenu__Icon[_ngcontent-%COMP%]{height:1.8rem;width:1.8rem;transition:.3s ease-in-out;border-radius:2px;display:flex;align-items:center;justify-content:center}.NgxBubbleMenu__Icon[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{fill:#fff}.NgxBubbleMenu__Icon[_ngcontent-%COMP%]:hover{background-color:#636262}.NgxBubbleMenu__Icon[_ngcontent-%COMP%] + .NgxBubbleMenu__Icon[_ngcontent-%COMP%]{margin-left:.3rem}.NgxBubbleMenu__Icon.NgxBubbleMenu__Icon--Active[_ngcontent-%COMP%]{background-color:#fff}.NgxBubbleMenu__Icon.NgxBubbleMenu__Icon--Active[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{fill:#000}.NgxBubbleMenu__Seperator[_ngcontent-%COMP%]{border-left:1px solid #fff;margin:0 5px}\"]\n  });\n  return BubbleComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BubbleComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-bubble',\n      templateUrl: './bubble.component.html',\n      styleUrls: ['./bubble.component.scss']\n    }]\n  }], function () {\n    return [{\n      type: SanitizeHtmlPipe\n    }, {\n      type: NgxEditorService\n    }];\n  }, {\n    editor: [{\n      type: Input\n    }]\n  });\n})();\n\nlet FloatingMenuComponent = /*@__PURE__*/(() => {\n  class FloatingMenuComponent {\n    constructor(el, sanitizeHTML) {\n      this.el = el;\n      this.sanitizeHTML = sanitizeHTML;\n      this.posLeft = 0;\n      this.posTop = 0;\n      this.showMenu = false;\n      this.dragging = false;\n      this.execulableItems = [];\n      this.activeItems = [];\n    }\n\n    get display() {\n      return {\n        visibility: this.showMenu ? 'visible' : 'hidden',\n        opacity: this.showMenu ? '1' : '0',\n        top: this.posTop + 'px',\n        left: this.posLeft + 'px'\n      };\n    }\n\n    get view() {\n      return this.editor.view;\n    }\n\n    onMouseDown(e) {\n      if (this.el.nativeElement.contains(e.target)) {\n        e.preventDefault();\n        return;\n      }\n\n      this.dragging = true;\n    }\n\n    onKeyDown() {\n      this.dragging = true;\n      this.hide();\n    }\n\n    onMouseUp() {\n      this.dragging = false;\n      this.useUpdate();\n    }\n\n    onKeyUp() {\n      this.dragging = false;\n      this.useUpdate();\n    }\n\n    useUpdate() {\n      if (!this.view) {\n        return;\n      }\n\n      this.update(this.view);\n    }\n\n    getIcon(name) {\n      const icon = Icon.getPath(name);\n      return this.sanitizeHTML.transform(icon);\n    }\n\n    hide() {\n      this.showMenu = false;\n    }\n\n    show() {\n      this.showMenu = true;\n    }\n\n    calculateBubblePosition(view) {\n      const {\n        state: {\n          selection\n        }\n      } = view;\n      const {\n        from\n      } = selection; // the floating bubble itself\n\n      const bubbleEl = this.el.nativeElement;\n      const bubble = bubbleEl.getBoundingClientRect(); // The box in which the tooltip is positioned, to use as base\n\n      const box = bubbleEl.parentElement.getBoundingClientRect();\n      const start = view.coordsAtPos(from);\n      let left = start.left - box.left;\n      const overflowsRight = box.right < start.left + bubble.width || bubble.right > box.right;\n\n      if (overflowsRight) {\n        left = box.width - bubble.width;\n      }\n\n      if (left < 0) {\n        left = 0;\n      }\n\n      const bubbleHeight = bubble.height + parseInt(getComputedStyle(bubbleEl).marginBottom, 10);\n      const top = start.top - box.top - bubbleHeight;\n      return {\n        left,\n        top\n      };\n    }\n\n    update(view) {\n      const {\n        state\n      } = view;\n      const {\n        selection\n      } = state;\n      const {\n        empty\n      } = selection;\n\n      if (selection instanceof NodeSelection) {\n        if (selection.node.type.name === 'image') {\n          this.hide();\n          return;\n        }\n      }\n\n      const hasFocus = this.view.hasFocus();\n\n      if (!hasFocus || empty || this.dragging) {\n        this.hide();\n        return;\n      }\n\n      const {\n        top,\n        left\n      } = this.calculateBubblePosition(this.view);\n      this.posLeft = left;\n      this.posTop = top;\n      this.show();\n    }\n\n    ngOnInit() {\n      if (!this.editor) {\n        throw new Error('NgxEditor: Required editor instance');\n      }\n\n      this.updateSubscription = this.editor.update.subscribe(view => {\n        this.update(view);\n      });\n      this.resizeSubscription = fromEvent(window, 'resize').pipe(throttleTime(500, asyncScheduler, {\n        leading: true,\n        trailing: true\n      })).subscribe(() => {\n        this.useUpdate();\n      });\n    }\n\n    ngOnDestroy() {\n      this.updateSubscription.unsubscribe();\n      this.resizeSubscription.unsubscribe();\n    }\n\n  }\n\n  FloatingMenuComponent.ɵfac = function FloatingMenuComponent_Factory(t) {\n    return new (t || FloatingMenuComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SanitizeHtmlPipe));\n  };\n\n  FloatingMenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FloatingMenuComponent,\n    selectors: [[\"ngx-editor-floating-menu\"]],\n    hostVars: 2,\n    hostBindings: function FloatingMenuComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function FloatingMenuComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMouseDown($event);\n        }, false, i0.ɵɵresolveDocument)(\"keydown\", function FloatingMenuComponent_keydown_HostBindingHandler() {\n          return ctx.onKeyDown();\n        }, false, i0.ɵɵresolveDocument)(\"mouseup\", function FloatingMenuComponent_mouseup_HostBindingHandler() {\n          return ctx.onMouseUp();\n        }, false, i0.ɵɵresolveDocument)(\"keyup\", function FloatingMenuComponent_keyup_HostBindingHandler() {\n          return ctx.onKeyUp();\n        }, false, i0.ɵɵresolveDocument);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleMap(ctx.display);\n      }\n    },\n    inputs: {\n      editor: \"editor\"\n    },\n    ngContentSelectors: _c3,\n    decls: 4,\n    vars: 1,\n    consts: [[\"ref\", \"\"], [4, \"ngIf\"], [3, \"editor\"]],\n    template: function FloatingMenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", null, 0);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, FloatingMenuComponent_ng_container_3_Template, 2, 1, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", _r0.children.length === 0);\n      }\n    },\n    directives: [i3.NgIf, BubbleComponent],\n    styles: [\"*[_ngcontent-%COMP%], [_ngcontent-%COMP%]:after, [_ngcontent-%COMP%]:before{box-sizing:border-box}[_nghost-%COMP%]{position:absolute;z-index:20;margin-bottom:.35rem;visibility:hidden;opacity:0}\"]\n  });\n  return FloatingMenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FloatingMenuComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-editor-floating-menu',\n      templateUrl: './floating-menu.component.html',\n      styleUrls: ['./floating-menu.component.scss']\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: SanitizeHtmlPipe\n    }];\n  }, {\n    display: [{\n      type: HostBinding,\n      args: ['style']\n    }],\n    editor: [{\n      type: Input\n    }],\n    onMouseDown: [{\n      type: HostListener,\n      args: ['document:mousedown', ['$event']]\n    }],\n    onKeyDown: [{\n      type: HostListener,\n      args: ['document:keydown']\n    }],\n    onMouseUp: [{\n      type: HostListener,\n      args: ['document:mouseup']\n    }],\n    onKeyUp: [{\n      type: HostListener,\n      args: ['document:keyup']\n    }]\n  });\n})();\n\nlet MenuModule = /*@__PURE__*/(() => {\n  class MenuModule {}\n\n  MenuModule.ɵfac = function MenuModule_Factory(t) {\n    return new (t || MenuModule)();\n  };\n\n  MenuModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MenuModule\n  });\n  MenuModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [SanitizeHtmlPipe],\n    imports: [[CommonModule, ReactiveFormsModule]]\n  });\n  return MenuModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MenuModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, ReactiveFormsModule],\n      declarations: [// pipes\n      SanitizeHtmlPipe, // components\n      MenuComponent, ToggleCommandComponent, LinkComponent, DropdownComponent, ImageComponent, ColorPickerComponent, FloatingMenuComponent, BubbleComponent],\n      providers: [SanitizeHtmlPipe],\n      exports: [MenuComponent, FloatingMenuComponent]\n    }]\n  }], null, null);\n})();\n\nconst NGX_EDITOR_CONFIG_TOKEN = new InjectionToken('NgxEditorConfig');\n\nlet NgxEditorModule = /*@__PURE__*/(() => {\n  class NgxEditorModule {\n    static forRoot(config) {\n      return {\n        ngModule: NgxEditorModule,\n        providers: [{\n          provide: NGX_EDITOR_CONFIG_TOKEN,\n          useValue: config\n        }, {\n          provide: NgxEditorServiceConfig,\n          useFactory: provideMyServiceOptions,\n          deps: [NGX_EDITOR_CONFIG_TOKEN]\n        }]\n      };\n    }\n\n    static forChild(config) {\n      return {\n        ngModule: NgxEditorModule,\n        providers: [{\n          provide: NGX_EDITOR_CONFIG_TOKEN,\n          useValue: config\n        }, {\n          provide: NgxEditorServiceConfig,\n          useFactory: provideMyServiceOptions,\n          deps: [NGX_EDITOR_CONFIG_TOKEN]\n        }, NgxEditorService]\n      };\n    }\n\n  }\n\n  NgxEditorModule.ɵfac = function NgxEditorModule_Factory(t) {\n    return new (t || NgxEditorModule)();\n  };\n\n  NgxEditorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxEditorModule\n  });\n  NgxEditorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[CommonModule, MenuModule]]\n  });\n  return NgxEditorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxEditorModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, MenuModule],\n      providers: [],\n      declarations: [NgxEditorComponent, ImageViewComponent],\n      exports: [NgxEditorComponent, MenuComponent, FloatingMenuComponent]\n    }]\n  }], null, null);\n})();\n\nconst isEmptyInputValue = value => {\n  // we don't check for string here so it also works with arrays\n  return value === null || value.length === 0;\n};\n\nconst hasValidLength = value => {\n  // non-strict comparison is intentional, to check for both `null` and `undefined` values\n  return value != null && typeof value.length === 'number';\n};\n\nconst isDocEmpty = doc => {\n  if (!doc) {\n    return true;\n  }\n\n  const {\n    childCount,\n    firstChild\n  } = doc;\n  return Boolean(childCount === 1 && (firstChild === null || firstChild === void 0 ? void 0 : firstChild.isTextblock) && firstChild.content.size === 0);\n}; // @dynamic\n\n\nclass Validators {\n  static required(userSchema) {\n    return control => {\n      const schema$1 = userSchema || schema;\n      const doc = parseContent(control.value, schema$1);\n      const isEmpty = isDocEmpty(doc);\n\n      if (!isEmpty) {\n        return null;\n      }\n\n      return {\n        required: true\n      };\n    };\n  }\n\n  static maxLength(maxLength, userSchema) {\n    return control => {\n      const schema$1 = userSchema || schema;\n      const doc = parseContent(control.value, schema$1);\n      const value = doc.textContent;\n\n      if (hasValidLength(value) && value.length > maxLength) {\n        return {\n          maxlength: {\n            requiredLength: maxLength,\n            actualLength: value.length\n          }\n        };\n      }\n\n      return null;\n    };\n  }\n\n  static minLength(minLength, userSchema) {\n    return control => {\n      const schema$1 = userSchema || schema;\n      const doc = parseContent(control.value, schema$1);\n      const value = doc.textContent;\n\n      if (isEmptyInputValue(value) || !hasValidLength(value)) {\n        // don't validate empty values to allow optional controls\n        // don't validate values without `length` property\n        return null;\n      }\n\n      if (value.length < minLength) {\n        return {\n          minlength: {\n            requiredLength: minLength,\n            actualLength: value.length\n          }\n        };\n      }\n\n      return null;\n    };\n  }\n\n}\n\nconst execMark = (name, toggle = false) => {\n  return (state, dispatch) => {\n    const command = new Mark(name);\n\n    if (!toggle) {\n      return command.apply()(state, dispatch);\n    }\n\n    return command.toggle()(state, dispatch);\n  };\n};\n\nclass EditorCommands {\n  constructor(view) {\n    this.applyTrx = tr => {\n      this.state = this.state.apply(tr !== null && tr !== void 0 ? tr : this.tr);\n      this.tr = this.state.tr;\n      this.tr.setMeta('APPLIED_TRX', true);\n    };\n\n    this.dispatch = tr => {\n      this.applyTrx(tr);\n    };\n\n    if (!view) {\n      throw Error('NgxEditor: Required view to initialize commands.');\n    }\n\n    this.view = view;\n    this.state = view.state;\n    this.tr = this.view.state.tr;\n  }\n\n  exec() {\n    // No changes applied\n    if (!this.tr.getMeta('APPLIED_TRX')) {\n      return false;\n    }\n\n    const forceEmit = !this.view.state.doc.eq(this.state.doc);\n    this.view.updateState(this.state);\n    const tr = this.tr.setMeta('FORCE_EMIT', forceEmit);\n    this.view.dispatch(tr);\n    return true;\n  }\n\n  focus() {\n    this.view.focus();\n    return this;\n  }\n\n  scrollIntoView() {\n    this.tr.scrollIntoView();\n    this.applyTrx();\n    return this;\n  }\n\n  insertText(text) {\n    this.tr.insertText(text);\n    this.applyTrx();\n    return this;\n  }\n\n  insertNewLine() {\n    const newLineCommands = [newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock];\n    chainCommands(...newLineCommands)(this.state, this.dispatch);\n    return this;\n  }\n\n  applyMark(name) {\n    execMark(name, false)(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleMark(name) {\n    execMark(name, true)(this.state, this.dispatch);\n    return this;\n  }\n\n  bold() {\n    execMark('strong')(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleBold() {\n    execMark('strong', true)(this.state, this.dispatch);\n    return this;\n  }\n\n  italics() {\n    execMark('em')(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleItalics() {\n    execMark('em', true)(this.state, this.dispatch);\n    return this;\n  }\n\n  underline() {\n    execMark('u')(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleUnderline() {\n    execMark('u', true)(this.state, this.dispatch);\n    return this;\n  }\n\n  strike() {\n    execMark('s')(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleStrike() {\n    execMark('s', true)(this.state, this.dispatch);\n    return this;\n  }\n\n  code() {\n    execMark('code')(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleCode() {\n    execMark('code', true)(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleOrderedList() {\n    const command = new ListItem(false);\n    command.toggle()(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleBulletList() {\n    const command = new ListItem(true);\n    command.toggle()(this.state, this.dispatch);\n    return this;\n  }\n\n  toggleHeading(level) {\n    const command = new Heading(level);\n    command.toggle()(this.state, this.dispatch);\n    return this;\n  }\n\n  insertLink(text, attrs) {\n    const command = new Link$1();\n    command.insert(text, attrs)(this.state, this.dispatch);\n    return this;\n  }\n\n  updateLink(attrs) {\n    const command = new Link$1();\n    command.update(attrs)(this.state, this.dispatch);\n    return this;\n  }\n\n  insertImage(src, attrs = {}) {\n    const command = new Image$1();\n    command.insert(src, attrs)(this.state, this.dispatch);\n    return this;\n  }\n\n  textColor(color) {\n    const command = new TextColor$1('text_color');\n    command.apply({\n      color\n    })(this.state, this.dispatch);\n    return this;\n  }\n\n  backgroundColor(color) {\n    const command = new TextColor$1('text_background_color');\n    command.apply({\n      backgroundColor: color\n    })(this.state, this.dispatch);\n    return this;\n  }\n\n  removeTextColor() {\n    const command = new TextColor$1('text_color');\n    command.remove()(this.state, this.dispatch);\n    return this;\n  }\n\n  removeBackgroundColor() {\n    const command = new TextColor$1('text_background_color');\n    command.remove()(this.state, this.dispatch);\n    return this;\n  }\n\n  align(p) {\n    const command = new TextAlign(p);\n    command.toggle()(this.state, this.dispatch);\n    return this;\n  }\n\n  insertHTML(html) {\n    const {\n      selection,\n      schema,\n      tr\n    } = this.state;\n    const {\n      from,\n      to\n    } = selection;\n    const element = document.createElement('div');\n    element.innerHTML = html.trim();\n    const slice = DOMParser.fromSchema(schema).parseSlice(element);\n    const transaction = tr.replaceRange(from, to, slice);\n    this.applyTrx(transaction);\n    return this;\n  }\n\n}\n\nconst isMacOs = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false; // Input rules ref: https://github.com/ProseMirror/prosemirror-example-setup/\n// : (NodeType) → InputRule\n// Given a blockquote node type, returns an input rule that turns `\"> \"`\n// at the start of a textblock into a blockquote.\n\nconst blockQuoteRule = nodeType => {\n  return wrappingInputRule(/^\\s*>\\s$/, nodeType);\n}; // : (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a number\n// followed by a dot at the start of a textblock into an ordered list.\n\n\nconst orderedListRule = nodeType => {\n  return wrappingInputRule(/^(\\d+)\\.\\s$/, nodeType, match => ({\n    order: +match[1]\n  }), (match, node) => node.childCount + node.attrs.order === +match[1]);\n}; // : (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a bullet\n// (dash, plush, or asterisk) at the start of a textblock into a\n// bullet list.\n\n\nconst bulletListRule = nodeType => {\n  return wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType);\n}; // : (NodeType) → InputRule\n// Given a code block node type, returns an input rule that turns a\n// textblock starting with three backticks into a code block.\n\n\nconst codeBlockRule = nodeType => {\n  return textblockTypeInputRule(/^```$/, nodeType);\n}; // : (NodeType, number) → InputRule\n// Given a node type and a maximum level, creates an input rule that\n// turns up to that number of `#` characters followed by a space at\n// the start of a textblock into a heading whose level corresponds to\n// the number of `#` signs.\n\n\nconst headingRule = (nodeType, maxLevel) => {\n  return textblockTypeInputRule(new RegExp('^(#{1,' + maxLevel + '})\\\\s$'), nodeType, match => ({\n    level: match[1].length\n  }));\n}; // : (Schema) → Plugin\n// A set of input rules for creating the basic block quotes, lists,\n// code blocks, and heading.\n\n\nconst buildInputRules = schema => {\n  const rules = smartQuotes.concat(ellipsis, emDash);\n  rules.push(blockQuoteRule(schema.nodes.blockquote));\n  rules.push(orderedListRule(schema.nodes.ordered_list));\n  rules.push(bulletListRule(schema.nodes.bullet_list));\n  rules.push(codeBlockRule(schema.nodes.code_block));\n  rules.push(headingRule(schema.nodes.heading, 6));\n  return inputRules({\n    rules\n  });\n};\n\nconst getKeyboardShortcuts = (schema, options) => {\n  const historyKeyMap = {};\n  historyKeyMap['Mod-z'] = undo;\n\n  if (isMacOs) {\n    historyKeyMap['Shift-Mod-z'] = redo;\n  } else {\n    historyKeyMap['Mod-y'] = redo;\n  }\n\n  const plugins = [keymap({\n    'Mod-b': toggleMark(schema.marks.strong),\n    'Mod-i': toggleMark(schema.marks.em),\n    'Mod-`': toggleMark(schema.marks.code)\n  }), keymap({\n    Enter: splitListItem(schema.nodes.list_item),\n    'Shift-Enter': chainCommands(exitCode, (state, dispatch) => {\n      const tr = state.tr;\n      const br = schema.nodes.hard_break;\n      dispatch(tr.replaceSelectionWith(br.create()).scrollIntoView());\n      return true;\n    }),\n    'Mod-[': liftListItem(schema.nodes.list_item),\n    'Mod-]': sinkListItem(schema.nodes.list_item),\n    Tab: sinkListItem(schema.nodes.list_item)\n  }), keymap(baseKeymap)];\n\n  if (options.history) {\n    plugins.push(keymap(historyKeyMap));\n  }\n\n  return plugins;\n};\n\nconst getDefaultPlugins = (schema, options) => {\n  const plugins = [];\n\n  if (options.keyboardShortcuts) {\n    plugins.push(...getKeyboardShortcuts(schema, {\n      history: options.history\n    }));\n  }\n\n  if (options.history) {\n    plugins.push(history());\n  }\n\n  if (options.inputRules) {\n    plugins.push(buildInputRules(schema));\n  }\n\n  return plugins;\n};\n\nconst DEFAULT_OPTIONS = {\n  content: null,\n  history: true,\n  keyboardShortcuts: true,\n  inputRules: true,\n  schema: schema,\n  plugins: [],\n  nodeViews: {}\n};\n\nclass Editor {\n  constructor(options = DEFAULT_OPTIONS) {\n    this.valueChangesSubject = new Subject();\n    this.updateSubject = new Subject();\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.createEditor();\n  }\n\n  get valueChanges() {\n    return this.valueChangesSubject.asObservable();\n  }\n\n  get update() {\n    return this.updateSubject.asObservable();\n  }\n\n  get schema() {\n    return this.options.schema || schema;\n  }\n\n  get commands() {\n    return new EditorCommands(this.view);\n  }\n\n  handleTransactions(tr) {\n    const state = this.view.state.apply(tr);\n    this.view.updateState(state);\n    this.updateSubject.next(this.view);\n\n    if (!tr.docChanged && !tr.getMeta('FORCE_EMIT')) {\n      return;\n    }\n\n    const json = state.doc.toJSON();\n    this.valueChangesSubject.next(json);\n  }\n\n  createEditor() {\n    var _a;\n\n    const {\n      options\n    } = this;\n    const {\n      content = null,\n      nodeViews\n    } = options;\n    const {\n      history = true,\n      keyboardShortcuts = true,\n      inputRules = true\n    } = options;\n    const schema = this.schema;\n    const doc = parseContent(content, schema);\n    const plugins = (_a = options.plugins) !== null && _a !== void 0 ? _a : [];\n    const defaultPlugins = getDefaultPlugins(schema, {\n      history,\n      keyboardShortcuts,\n      inputRules\n    });\n    this.view = new EditorView(null, {\n      state: EditorState.create({\n        doc,\n        schema,\n        plugins: [...defaultPlugins, ...plugins]\n      }),\n      nodeViews,\n      dispatchTransaction: this.handleTransactions.bind(this)\n    });\n  }\n\n  setContent(content) {\n    if (isNil(content)) {\n      return;\n    }\n\n    const {\n      state\n    } = this.view;\n    const {\n      tr,\n      doc\n    } = state;\n    const newDoc = parseContent(content, this.schema);\n    tr.replaceWith(0, state.doc.content.size, newDoc); // don't emit if both content is same\n\n    if (doc.eq(tr.doc)) {\n      return;\n    }\n\n    if (!tr.docChanged) {\n      return;\n    }\n\n    this.view.dispatch(tr);\n  }\n\n  registerPlugin(plugin) {\n    const {\n      state\n    } = this.view;\n    const plugins = [...state.plugins, plugin];\n    const newState = state.reconfigure({\n      plugins\n    });\n    this.view.updateState(newState);\n  }\n\n  destroy() {\n    this.view.destroy();\n  }\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Editor, FloatingMenuComponent, MenuComponent, NgxEditorComponent, NgxEditorModule, Validators, emptyDoc, parseContent, toDoc, toHTML }; //# sourceMappingURL=ngx-editor.js.map","map":null,"metadata":{},"sourceType":"module"}